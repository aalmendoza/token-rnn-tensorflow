struct sharedObjectsStruct shared ; double R_Zero , R_PosInf , R_NegInf , R_Nan ; struct redisServer server ; struct redisCommand redisCommandTable [ ] = { { <str> , getCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , setCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , setnxCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , setexCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , psetexCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , appendCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , strlenCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , delCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , unlinkCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , existsCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , setbitCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , getbitCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , bitfieldCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , setrangeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , getrangeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , getrangeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , incrCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , decrCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , mgetCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , rpushCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lpushCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , rpushxCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lpushxCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , linsertCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , rpopCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lpopCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , brpopCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , brpoplpushCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , blpopCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , llenCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lindexCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lsetCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lrangeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , ltrimCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lremCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , rpoplpushCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , saddCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , sremCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , smoveCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , sismemberCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , scardCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , spopCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , srandmemberCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , sinterCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sinterstoreCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sunionCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sunionstoreCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sdiffCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sdiffstoreCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , sinterCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , sscanCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zaddCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zincrbyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zremCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zremrangebyscoreCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zremrangebyrankCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zremrangebylexCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zunionstoreCommand , - <int> , <str> , <int> , zunionInterGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , zinterstoreCommand , - <int> , <str> , <int> , zunionInterGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , zrangeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrangebyscoreCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrevrangebyscoreCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrangebylexCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrevrangebylexCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zcountCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zlexcountCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrevrangeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zcardCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zscoreCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrankCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zrevrankCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , zscanCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hsetCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hsetnxCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hgetCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hmsetCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hmgetCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hincrbyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hincrbyfloatCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hdelCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hlenCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hstrlenCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hkeysCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hvalsCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hgetallCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hexistsCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , hscanCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , incrbyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , decrbyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , incrbyfloatCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , getsetCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , msetCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , msetnxCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , randomkeyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , selectCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , moveCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , renameCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , renamenxCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , expireCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , expireatCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pexpireCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pexpireatCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , keysCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , scanCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , dbsizeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , authCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pingCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , echoCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , saveCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , bgsaveCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , bgrewriteaofCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , shutdownCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , lastsaveCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , typeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , multiCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , execCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , discardCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , syncCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , syncCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , replconfCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , flushdbCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , flushallCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , sortCommand , - <int> , <str> , <int> , sortGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , infoCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , monitorCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , ttlCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pttlCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , persistCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , slaveofCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , roleCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , debugCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , configCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , subscribeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , unsubscribeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , psubscribeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , punsubscribeCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , publishCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pubsubCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , watchCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , unwatchCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , clusterCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , restoreCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , restoreCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , migrateCommand , - <int> , <str> , <int> , migrateGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , askingCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , readonlyCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , readwriteCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , dumpCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , objectCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , clientCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , evalCommand , - <int> , <str> , <int> , evalGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , evalShaCommand , - <int> , <str> , <int> , evalGetKeys , <int> , <int> , <int> , <int> , <int> } , { <str> , slowlogCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , scriptCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , timeCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , bitopCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , bitcountCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , bitposCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , waitCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , commandCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , geoaddCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , georadiusCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , georadiusByMemberCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , geohashCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , geoposCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , geodistCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pfselftestCommand , <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pfaddCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , pfcountCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , pfmergeCommand , - <int> , <str> , <int> , NULL , <int> , - <int> , <int> , <int> , <int> } , { <str> , pfdebugCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } , { <str> , latencyCommand , - <int> , <str> , <int> , NULL , <int> , <int> , <int> , <int> , <int> } } ; struct evictionPoolEntry * evictionPoolAlloc ( void ) ; void serverLogRaw ( int level , const char * msg ) { const int syslogLevelMap [ ] = { LOG_DEBUG , LOG_INFO , LOG_NOTICE , LOG_WARNING } ; const char * c = <str> ; FILE * fp ; char buf [ <int> ] ; int rawmode = ( level & LL_RAW ) ; int log_to_stdout = server . logfile [ <int> ] = = <str> ; level & = <hex> ; if ( level < server . verbosity ) return ; fp = log_to_stdout ? stdout : fopen ( server . logfile , <str> ) ; if ( ! fp ) return ; if ( rawmode ) { fprintf ( fp , <str> , msg ) ; } else { int off ; struct timeval tv ; int role_char ; pid_t pid = getpid ( ) ; gettimeofday ( & tv , NULL ) ; off = strftime ( buf , sizeof ( buf ) , <str> , localtime ( & tv . tv_sec ) ) ; snprintf ( buf + off , sizeof ( buf ) - off , <str> , ( int ) tv . tv_usec / <int> ) ; if ( server . sentinel_mode ) { role_char = <str> ; } else if ( pid ! = server . pid ) { role_char = <str> ; } else { role_char = ( server . masterhost ? <str> : <str> ) ; } fprintf ( fp , <str> , ( int ) getpid ( ) , role_char , buf , c [ level ] , msg ) ; } fflush ( fp ) ; if ( ! log_to_stdout ) fclose ( fp ) ; if ( server . syslog_enabled ) syslog ( syslogLevelMap [ level ] , <str> , msg ) ; } void serverLog ( int level , const char * fmt , . . . ) { va_list ap ; char msg [ LOG_MAX_LEN ] ; if ( ( level & <hex> ) < server . verbosity ) return ; va_start ( ap , fmt ) ; vsnprintf ( msg , sizeof ( msg ) , fmt , ap ) ; va_end ( ap ) ; serverLogRaw ( level , msg ) ; } void serverLogFromHandler ( int level , const char * msg ) { int fd ; int log_to_stdout = server . logfile [ <int> ] = = <str> ; char buf [ <int> ] ; if ( ( level & <hex> ) < server . verbosity | | ( log_to_stdout & & server . daemonize ) ) return ; fd = log_to_stdout ? STDOUT_FILENO : open ( server . logfile , O_APPEND | O_CREAT | O_WRONLY , <oct> ) ; if ( fd = = - <int> ) return ; ll2string ( buf , sizeof ( buf ) , getpid ( ) ) ; if ( write ( fd , buf , strlen ( buf ) ) = = - <int> ) goto err ; if ( write ( fd , <str> , <int> ) = = - <int> ) goto err ; ll2string ( buf , sizeof ( buf ) , time ( NULL ) ) ; if ( write ( fd , buf , strlen ( buf ) ) = = - <int> ) goto err ; if ( write ( fd , <str> , <int> ) = = - <int> ) goto err ; if ( write ( fd , msg , strlen ( msg ) ) = = - <int> ) goto err ; if ( write ( fd , <str> , <int> ) = = - <int> ) goto err ; err : if ( ! log_to_stdout ) close ( fd ) ; } long long ustime ( void ) { struct timeval tv ; long long ust ; gettimeofday ( & tv , NULL ) ; ust = ( ( long long ) tv . tv_sec ) * <int> ; ust + = tv . tv_usec ; return ust ; } mstime_t mstime ( void ) { return ustime ( ) / <int> ; } void exitFromChild ( int retcode ) { exit ( retcode ) ; _exit ( retcode ) ; } void dictVanillaFree ( void * privdata , void * val ) { DICT_NOTUSED ( privdata ) ; zfree ( val ) ; } void dictListDestructor ( void * privdata , void * val ) { DICT_NOTUSED ( privdata ) ; listRelease ( ( list * ) val ) ; } int dictSdsKeyCompare ( void * privdata , const void * key1 , const void * key2 ) { int l1 , l2 ; DICT_NOTUSED ( privdata ) ; l1 = sdslen ( ( sds ) key1 ) ; l2 = sdslen ( ( sds ) key2 ) ; if ( l1 ! = l2 ) return <int> ; return memcmp ( key1 , key2 , l1 ) = = <int> ; } int dictSdsKeyCaseCompare ( void * privdata , const void * key1 , const void * key2 ) { DICT_NOTUSED ( privdata ) ; return strcasecmp ( key1 , key2 ) = = <int> ; } void dictObjectDestructor ( void * privdata , void * val ) { DICT_NOTUSED ( privdata ) ; if ( val = = NULL ) return ; decrRefCount ( val ) ; } void dictSdsDestructor ( void * privdata , void * val ) { DICT_NOTUSED ( privdata ) ; sdsfree ( val ) ; } int dictObjKeyCompare ( void * privdata , const void * key1 , const void * key2 ) { const robj * o1 = key1 , * o2 = key2 ; return dictSdsKeyCompare ( privdata , o1 - > ptr , o2 - > ptr ) ; } unsigned int dictObjHash ( const void * key ) { const robj * o = key ; return dictGenHashFunction ( o - > ptr , sdslen ( ( sds ) o - > ptr ) ) ; } unsigned int dictSdsHash ( const void * key ) { return dictGenHashFunction ( ( unsigned char * ) key , sdslen ( ( char * ) key ) ) ; } unsigned int dictSdsCaseHash ( const void * key ) { return dictGenCaseHashFunction ( ( unsigned char * ) key , sdslen ( ( char * ) key ) ) ; } int dictEncObjKeyCompare ( void * privdata , const void * key1 , const void * key2 ) { robj * o1 = ( robj * ) key1 , * o2 = ( robj * ) key2 ; int cmp ; if ( o1 - > encoding = = OBJ_ENCODING_INT & & o2 - > encoding = = OBJ_ENCODING_INT ) return o1 - > ptr = = o2 - > ptr ; o1 = getDecodedObject ( o1 ) ; o2 = getDecodedObject ( o2 ) ; cmp = dictSdsKeyCompare ( privdata , o1 - > ptr , o2 - > ptr ) ; decrRefCount ( o1 ) ; decrRefCount ( o2 ) ; return cmp ; } unsigned int dictEncObjHash ( const void * key ) { robj * o = ( robj * ) key ; if ( sdsEncodedObject ( o ) ) { return dictGenHashFunction ( o - > ptr , sdslen ( ( sds ) o - > ptr ) ) ; } else { if ( o - > encoding = = OBJ_ENCODING_INT ) { char buf [ <int> ] ; int len ; len = ll2string ( buf , <int> , ( long ) o - > ptr ) ; return dictGenHashFunction ( ( unsigned char * ) buf , len ) ; } else { unsigned int hash ; o = getDecodedObject ( o ) ; hash = dictGenHashFunction ( o - > ptr , sdslen ( ( sds ) o - > ptr ) ) ; decrRefCount ( o ) ; return hash ; } } } dictType objectKeyPointerValueDictType = { dictEncObjHash , NULL , NULL , dictEncObjKeyCompare , dictObjectDestructor , NULL } ; dictType setDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , dictSdsDestructor , NULL } ; dictType zsetDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , NULL , NULL } ; dictType dbDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , dictSdsDestructor , dictObjectDestructor } ; dictType shaScriptObjectDictType = { dictSdsCaseHash , NULL , NULL , dictSdsKeyCaseCompare , dictSdsDestructor , dictObjectDestructor } ; dictType keyptrDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , NULL , NULL } ; dictType commandTableDictType = { dictSdsCaseHash , NULL , NULL , dictSdsKeyCaseCompare , dictSdsDestructor , NULL } ; dictType hashDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , dictSdsDestructor , dictSdsDestructor } ; dictType keylistDictType = { dictObjHash , NULL , NULL , dictObjKeyCompare , dictObjectDestructor , dictListDestructor } ; dictType clusterNodesDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , dictSdsDestructor , NULL } ; dictType clusterNodesBlackListDictType = { dictSdsCaseHash , NULL , NULL , dictSdsKeyCaseCompare , dictSdsDestructor , NULL } ; dictType migrateCacheDictType = { dictSdsHash , NULL , NULL , dictSdsKeyCompare , dictSdsDestructor , NULL } ; dictType replScriptCacheDictType = { dictSdsCaseHash , NULL , NULL , dictSdsKeyCaseCompare , dictSdsDestructor , NULL } ; int htNeedsResize ( dict * dict ) { long long size , used ; size = dictSlots ( dict ) ; used = dictSize ( dict ) ; return ( size & & used & & size > DICT_HT_INITIAL_SIZE & & ( used * <int> / size < HASHTABLE_MIN_FILL ) ) ; } void tryResizeHashTables ( int dbid ) { if ( htNeedsResize ( server . db [ dbid ] . dict ) ) dictResize ( server . db [ dbid ] . dict ) ; if ( htNeedsResize ( server . db [ dbid ] . expires ) ) dictResize ( server . db [ dbid ] . expires ) ; } int incrementallyRehash ( int dbid ) { if ( dictIsRehashing ( server . db [ dbid ] . dict ) ) { dictRehashMilliseconds ( server . db [ dbid ] . dict , <int> ) ; return <int> ; } if ( dictIsRehashing ( server . db [ dbid ] . expires ) ) { dictRehashMilliseconds ( server . db [ dbid ] . expires , <int> ) ; return <int> ; } return <int> ; } void updateDictResizePolicy ( void ) { if ( server . rdb_child_pid = = - <int> & & server . aof_child_pid = = - <int> ) dictEnableResize ( ) ; else dictDisableResize ( ) ; } int activeExpireCycleTryExpire ( redisDb * db , dictEntry * de , long long now ) { long long t = dictGetSignedIntegerVal ( de ) ; if ( now > t ) { sds key = dictGetKey ( de ) ; robj * keyobj = createStringObject ( key , sdslen ( key ) ) ; propagateExpire ( db , keyobj , server . lazyfree_lazy_expire ) ; if ( server . lazyfree_lazy_expire ) dbAsyncDelete ( db , keyobj ) ; else dbSyncDelete ( db , keyobj ) ; notifyKeyspaceEvent ( NOTIFY_EXPIRED , <str> , keyobj , db - > id ) ; decrRefCount ( keyobj ) ; server . stat_expiredkeys + + ; return <int> ; } else { return <int> ; } } void activeExpireCycle ( int type ) { static unsigned int current_db = <int> ; static int timelimit_exit = <int> ; static long long last_fast_cycle = <int> ; int j , iteration = <int> ; int dbs_per_call = CRON_DBS_PER_CALL ; long long start = ustime ( ) , timelimit ; if ( type = = ACTIVE_EXPIRE_CYCLE_FAST ) { if ( ! timelimit_exit ) return ; if ( start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION * <int> ) return ; last_fast_cycle = start ; } if ( dbs_per_call > server . dbnum | | timelimit_exit ) dbs_per_call = server . dbnum ; timelimit = <int> * ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC / server . hz / <int> ; timelimit_exit = <int> ; if ( timelimit < = <int> ) timelimit = <int> ; if ( type = = ACTIVE_EXPIRE_CYCLE_FAST ) timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION ; for ( j = <int> ; j < dbs_per_call ; j + + ) { int expired ; redisDb * db = server . db + ( current_db % server . dbnum ) ; current_db + + ; do { unsigned long num , slots ; long long now , ttl_sum ; int ttl_samples ; if ( ( num = dictSize ( db - > expires ) ) = = <int> ) { db - > avg_ttl = <int> ; break ; } slots = dictSlots ( db - > expires ) ; now = mstime ( ) ; if ( num & & slots > DICT_HT_INITIAL_SIZE & & ( num * <int> / slots < <int> ) ) break ; expired = <int> ; ttl_sum = <int> ; ttl_samples = <int> ; if ( num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP ) num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP ; while ( num - - ) { dictEntry * de ; long long ttl ; if ( ( de = dictGetRandomKey ( db - > expires ) ) = = NULL ) break ; ttl = dictGetSignedIntegerVal ( de ) - now ; if ( activeExpireCycleTryExpire ( db , de , now ) ) expired + + ; if ( ttl > <int> ) { ttl_sum + = ttl ; ttl_samples + + ; } } if ( ttl_samples ) { long long avg_ttl = ttl_sum / ttl_samples ; if ( db - > avg_ttl = = <int> ) db - > avg_ttl = avg_ttl ; db - > avg_ttl = ( db - > avg_ttl / <int> ) * <int> + ( avg_ttl / <int> ) ; } iteration + + ; if ( ( iteration & <hex> ) = = <int> ) { long long elapsed = ustime ( ) - start ; latencyAddSampleIfNeeded ( <str> , elapsed / <int> ) ; if ( elapsed > timelimit ) timelimit_exit = <int> ; } if ( timelimit_exit ) return ; } while ( expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP / <int> ) ; } } unsigned int getLRUClock ( void ) { return ( mstime ( ) / LRU_CLOCK_RESOLUTION ) & LRU_CLOCK_MAX ; } void trackInstantaneousMetric ( int metric , long long current_reading ) { long long t = mstime ( ) - server . inst_metric [ metric ] . last_sample_time ; long long ops = current_reading - server . inst_metric [ metric ] . last_sample_count ; long long ops_sec ; ops_sec = t > <int> ? ( ops * <int> / t ) : <int> ; server . inst_metric [ metric ] . samples [ server . inst_metric [ metric ] . idx ] = ops_sec ; server . inst_metric [ metric ] . idx + + ; server . inst_metric [ metric ] . idx % = STATS_METRIC_SAMPLES ; server . inst_metric [ metric ] . last_sample_time = mstime ( ) ; server . inst_metric [ metric ] . last_sample_count = current_reading ; } long long getInstantaneousMetric ( int metric ) { int j ; long long sum = <int> ; for ( j = <int> ; j < STATS_METRIC_SAMPLES ; j + + ) sum + = server . inst_metric [ metric ] . samples [ j ] ; return sum / STATS_METRIC_SAMPLES ; } int clientsCronHandleTimeout ( client * c , mstime_t now_ms ) { time_t now = now_ms / <int> ; if ( server . maxidletime & & ! ( c - > flags & CLIENT_SLAVE ) & & ! ( c - > flags & CLIENT_MASTER ) & & ! ( c - > flags & CLIENT_BLOCKED ) & & ! ( c - > flags & CLIENT_PUBSUB ) & & ( now - c - > lastinteraction > server . maxidletime ) ) { serverLog ( LL_VERBOSE , <str> ) ; freeClient ( c ) ; return <int> ; } else if ( c - > flags & CLIENT_BLOCKED ) { if ( c - > bpop . timeout ! = <int> & & c - > bpop . timeout < now_ms ) { replyToBlockedClientTimedOut ( c ) ; unblockClient ( c ) ; } else if ( server . cluster_enabled ) { if ( clusterRedirectBlockedClientIfNeeded ( c ) ) unblockClient ( c ) ; } } return <int> ; } int clientsCronResizeQueryBuffer ( client * c ) { size_t querybuf_size = sdsAllocSize ( c - > querybuf ) ; time_t idletime = server . unixtime - c - > lastinteraction ; if ( ( ( querybuf_size > PROTO_MBULK_BIG_ARG ) & & ( querybuf_size / ( c - > querybuf_peak + <int> ) ) > <int> ) | | ( querybuf_size > <int> & & idletime > <int> ) ) { if ( sdsavail ( c - > querybuf ) > <int> ) { c - > querybuf = sdsRemoveFreeSpace ( c - > querybuf ) ; } } c - > querybuf_peak = <int> ; return <int> ; } void clientsCron ( void ) { int numclients = listLength ( server . clients ) ; int iterations = numclients / server . hz ; mstime_t now = mstime ( ) ; if ( iterations < CLIENTS_CRON_MIN_ITERATIONS ) iterations = ( numclients < CLIENTS_CRON_MIN_ITERATIONS ) ? numclients : CLIENTS_CRON_MIN_ITERATIONS ; while ( listLength ( server . clients ) & & iterations - - ) { client * c ; listNode * head ; listRotate ( server . clients ) ; head = listFirst ( server . clients ) ; c = listNodeValue ( head ) ; if ( clientsCronHandleTimeout ( c , now ) ) continue ; if ( clientsCronResizeQueryBuffer ( c ) ) continue ; } } void databasesCron ( void ) { if ( server . active_expire_enabled & & server . masterhost = = NULL ) activeExpireCycle ( ACTIVE_EXPIRE_CYCLE_SLOW ) ; if ( server . rdb_child_pid = = - <int> & & server . aof_child_pid = = - <int> ) { static unsigned int resize_db = <int> ; static unsigned int rehash_db = <int> ; int dbs_per_call = CRON_DBS_PER_CALL ; int j ; if ( dbs_per_call > server . dbnum ) dbs_per_call = server . dbnum ; for ( j = <int> ; j < dbs_per_call ; j + + ) { tryResizeHashTables ( resize_db % server . dbnum ) ; resize_db + + ; } if ( server . activerehashing ) { for ( j = <int> ; j < dbs_per_call ; j + + ) { int work_done = incrementallyRehash ( rehash_db % server . dbnum ) ; rehash_db + + ; if ( work_done ) { break ; } } } } } void updateCachedTime ( void ) { server . unixtime = time ( NULL ) ; server . mstime = mstime ( ) ; } int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j ; UNUSED ( eventLoop ) ; UNUSED ( id ) ; UNUSED ( clientData ) ; if ( server . watchdog_period ) watchdogScheduleSignal ( server . watchdog_period ) ; updateCachedTime ( ) ; run_with_period ( <int> ) { trackInstantaneousMetric ( STATS_METRIC_COMMAND , server . stat_numcommands ) ; trackInstantaneousMetric ( STATS_METRIC_NET_INPUT , server . stat_net_input_bytes ) ; trackInstantaneousMetric ( STATS_METRIC_NET_OUTPUT , server . stat_net_output_bytes ) ; } server . lruclock = getLRUClock ( ) ; if ( zmalloc_used_memory ( ) > server . stat_peak_memory ) server . stat_peak_memory = zmalloc_used_memory ( ) ; server . resident_set_size = zmalloc_get_rss ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( SHUTDOWN_NOFLAGS ) = = C_OK ) exit ( <int> ) ; serverLog ( LL_WARNING , <str> ) ; server . shutdown_asap = <int> ; } run_with_period ( <int> ) { for ( j = <int> ; j < server . dbnum ; j + + ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( used | | vkeys ) { serverLog ( LL_VERBOSE , <str> , j , used , vkeys , size ) ; } } } if ( ! server . sentinel_mode ) { run_with_period ( <int> ) { serverLog ( LL_VERBOSE , <str> , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } } clientsCron ( ) ; databasesCron ( ) ; if ( server . rdb_child_pid = = - <int> & & server . aof_child_pid = = - <int> & & server . aof_rewrite_scheduled ) { rewriteAppendOnlyFileBackground ( ) ; } if ( server . rdb_child_pid ! = - <int> | | server . aof_child_pid ! = - <int> | | ldbPendingChildren ( ) ) { int statloc ; pid_t pid ; if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) ! = <int> ) { int exitcode = WEXITSTATUS ( statloc ) ; int bysignal = <int> ; if ( WIFSIGNALED ( statloc ) ) bysignal = WTERMSIG ( statloc ) ; if ( pid = = - <int> ) { serverLog ( LL_WARNING , <str> <str> , strerror ( errno ) , ( int ) server . rdb_child_pid , ( int ) server . aof_child_pid ) ; } else if ( pid = = server . rdb_child_pid ) { backgroundSaveDoneHandler ( exitcode , bysignal ) ; } else if ( pid = = server . aof_child_pid ) { backgroundRewriteDoneHandler ( exitcode , bysignal ) ; } else { if ( ! ldbRemoveChild ( pid ) ) { serverLog ( LL_WARNING , <str> , ( long ) pid ) ; } } updateDictResizePolicy ( ) ; } } else { for ( j = <int> ; j < server . saveparamslen ; j + + ) { struct saveparam * sp = server . saveparams + j ; if ( server . dirty > = sp - > changes & & server . unixtime - server . lastsave > sp - > seconds & & ( server . unixtime - server . lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY | | server . lastbgsave_status = = C_OK ) ) { serverLog ( LL_NOTICE , <str> , sp - > changes , ( int ) sp - > seconds ) ; rdbSaveBackground ( server . rdb_filename ) ; break ; } } if ( server . rdb_child_pid = = - <int> & & server . aof_child_pid = = - <int> & & server . aof_rewrite_perc & & server . aof_current_size > server . aof_rewrite_min_size ) { long long base = server . aof_rewrite_base_size ? server . aof_rewrite_base_size : <int> ; long long growth = ( server . aof_current_size * <int> / base ) - <int> ; if ( growth > = server . aof_rewrite_perc ) { serverLog ( LL_NOTICE , <str> , growth ) ; rewriteAppendOnlyFileBackground ( ) ; } } } if ( server . aof_flush_postponed_start ) flushAppendOnlyFile ( <int> ) ; run_with_period ( <int> ) { if ( server . aof_last_write_status = = C_ERR ) flushAppendOnlyFile ( <int> ) ; } freeClientsInAsyncFreeQueue ( ) ; clientsArePaused ( ) ; run_with_period ( <int> ) replicationCron ( ) ; run_with_period ( <int> ) { if ( server . cluster_enabled ) clusterCron ( ) ; } run_with_period ( <int> ) { if ( server . sentinel_mode ) sentinelTimer ( ) ; } run_with_period ( <int> ) { migrateCloseTimedoutSockets ( ) ; } server . cronloops + + ; return <int> / server . hz ; } void beforeSleep ( struct aeEventLoop * eventLoop ) { UNUSED ( eventLoop ) ; if ( server . cluster_enabled ) clusterBeforeSleep ( ) ; if ( server . active_expire_enabled & & server . masterhost = = NULL ) activeExpireCycle ( ACTIVE_EXPIRE_CYCLE_FAST ) ; if ( server . get_ack_from_slaves ) { robj * argv [ <int> ] ; argv [ <int> ] = createStringObject ( <str> , <int> ) ; argv [ <int> ] = createStringObject ( <str> , <int> ) ; argv [ <int> ] = createStringObject ( <str> , <int> ) ; replicationFeedSlaves ( server . slaves , server . slaveseldb , argv , <int> ) ; decrRefCount ( argv [ <int> ] ) ; decrRefCount ( argv [ <int> ] ) ; decrRefCount ( argv [ <int> ] ) ; server . get_ack_from_slaves = <int> ; } if ( listLength ( server . clients_waiting_acks ) ) processClientsWaitingReplicas ( ) ; if ( listLength ( server . unblocked_clients ) ) processUnblockedClients ( ) ; flushAppendOnlyFile ( <int> ) ; handleClientsWithPendingWrites ( ) ; } void createSharedObjects ( void ) { int j ; shared . crlf = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . ok = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . err = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . emptybulk = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . czero = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . cone = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . cnegone = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . nullbulk = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . nullmultibulk = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . emptymultibulk = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . pong = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . queued = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . emptyscan = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . wrongtypeerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . nokeyerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . syntaxerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . sameobjecterr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . outofrangeerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . noscripterr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . loadingerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . slowscripterr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . masterdownerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . bgsaveerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . roslaveerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . noautherr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . oomerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . execaborterr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . noreplicaserr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . busykeyerr = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . space = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . colon = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; shared . plus = createObject ( OBJ_STRING , sdsnew ( <str> ) ) ; for ( j = <int> ; j < PROTO_SHARED_SELECT_CMDS ; j + + ) { char dictid_str [ <int> ] ; int dictid_len ; dictid_len = ll2string ( dictid_str , sizeof ( dictid_str ) , j ) ; shared . select [ j ] = createObject ( OBJ_STRING , sdscatprintf ( sdsempty ( ) , <str> , dictid_len , dictid_str ) ) ; } shared . messagebulk = createStringObject ( <str> , <int> ) ; shared . pmessagebulk = createStringObject ( <str> , <int> ) ; shared . subscribebulk = createStringObject ( <str> , <int> ) ; shared . unsubscribebulk = createStringObject ( <str> , <int> ) ; shared . psubscribebulk = createStringObject ( <str> , <int> ) ; shared . punsubscribebulk = createStringObject ( <str> , <int> ) ; shared . del = createStringObject ( <str> , <int> ) ; shared . unlink = createStringObject ( <str> , <int> ) ; shared . rpop = createStringObject ( <str> , <int> ) ; shared . lpop = createStringObject ( <str> , <int> ) ; shared . lpush = createStringObject ( <str> , <int> ) ; for ( j = <int> ; j < OBJ_SHARED_INTEGERS ; j + + ) { shared . integers [ j ] = makeObjectShared ( createObject ( OBJ_STRING , ( void * ) ( long ) j ) ) ; shared . integers [ j ] - > encoding = OBJ_ENCODING_INT ; } for ( j = <int> ; j < OBJ_SHARED_BULKHDR_LEN ; j + + ) { shared . mbulkhdr [ j ] = createObject ( OBJ_STRING , sdscatprintf ( sdsempty ( ) , <str> , j ) ) ; shared . bulkhdr [ j ] = createObject ( OBJ_STRING , sdscatprintf ( sdsempty ( ) , <str> , j ) ) ; } shared . minstring = sdsnew ( <str> ) ; shared . maxstring = sdsnew ( <str> ) ; } void initServerConfig ( void ) { int j ; getRandomHexChars ( server . runid , CONFIG_RUN_ID_SIZE ) ; server . configfile = NULL ; server . executable = NULL ; server . hz = CONFIG_DEFAULT_HZ ; server . runid [ CONFIG_RUN_ID_SIZE ] = <str> ; server . arch_bits = ( sizeof ( long ) = = <int> ) ? <int> : <int> ; server . port = CONFIG_DEFAULT_SERVER_PORT ; server . tcp_backlog = CONFIG_DEFAULT_TCP_BACKLOG ; server . bindaddr_count = <int> ; server . unixsocket = NULL ; server . unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM ; server . ipfd_count = <int> ; server . sofd = - <int> ; server . protected_mode = CONFIG_DEFAULT_PROTECTED_MODE ; server . dbnum = CONFIG_DEFAULT_DBNUM ; server . verbosity = CONFIG_DEFAULT_VERBOSITY ; server . maxidletime = CONFIG_DEFAULT_CLIENT_TIMEOUT ; server . tcpkeepalive = CONFIG_DEFAULT_TCP_KEEPALIVE ; server . active_expire_enabled = <int> ; server . client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN ; server . saveparams = NULL ; server . loading = <int> ; server . logfile = zstrdup ( CONFIG_DEFAULT_LOGFILE ) ; server . syslog_enabled = CONFIG_DEFAULT_SYSLOG_ENABLED ; server . syslog_ident = zstrdup ( CONFIG_DEFAULT_SYSLOG_IDENT ) ; server . syslog_facility = LOG_LOCAL0 ; server . daemonize = CONFIG_DEFAULT_DAEMONIZE ; server . supervised = <int> ; server . supervised_mode = SUPERVISED_NONE ; server . aof_state = AOF_OFF ; server . aof_fsync = CONFIG_DEFAULT_AOF_FSYNC ; server . aof_no_fsync_on_rewrite = CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE ; server . aof_rewrite_perc = AOF_REWRITE_PERC ; server . aof_rewrite_min_size = AOF_REWRITE_MIN_SIZE ; server . aof_rewrite_base_size = <int> ; server . aof_rewrite_scheduled = <int> ; server . aof_last_fsync = time ( NULL ) ; server . aof_rewrite_time_last = - <int> ; server . aof_rewrite_time_start = - <int> ; server . aof_lastbgrewrite_status = C_OK ; server . aof_delayed_fsync = <int> ; server . aof_fd = - <int> ; server . aof_selected_db = - <int> ; server . aof_flush_postponed_start = <int> ; server . aof_rewrite_incremental_fsync = CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC ; server . aof_load_truncated = CONFIG_DEFAULT_AOF_LOAD_TRUNCATED ; server . pidfile = NULL ; server . rdb_filename = zstrdup ( CONFIG_DEFAULT_RDB_FILENAME ) ; server . aof_filename = zstrdup ( CONFIG_DEFAULT_AOF_FILENAME ) ; server . requirepass = NULL ; server . rdb_compression = CONFIG_DEFAULT_RDB_COMPRESSION ; server . rdb_checksum = CONFIG_DEFAULT_RDB_CHECKSUM ; server . stop_writes_on_bgsave_err = CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR ; server . activerehashing = CONFIG_DEFAULT_ACTIVE_REHASHING ; server . notify_keyspace_events = <int> ; server . maxclients = CONFIG_DEFAULT_MAX_CLIENTS ; server . bpop_blocked_clients = <int> ; server . maxmemory = CONFIG_DEFAULT_MAXMEMORY ; server . maxmemory_policy = CONFIG_DEFAULT_MAXMEMORY_POLICY ; server . maxmemory_samples = CONFIG_DEFAULT_MAXMEMORY_SAMPLES ; server . hash_max_ziplist_entries = OBJ_HASH_MAX_ZIPLIST_ENTRIES ; server . hash_max_ziplist_value = OBJ_HASH_MAX_ZIPLIST_VALUE ; server . list_max_ziplist_size = OBJ_LIST_MAX_ZIPLIST_SIZE ; server . list_compress_depth = OBJ_LIST_COMPRESS_DEPTH ; server . set_max_intset_entries = OBJ_SET_MAX_INTSET_ENTRIES ; server . zset_max_ziplist_entries = OBJ_ZSET_MAX_ZIPLIST_ENTRIES ; server . zset_max_ziplist_value = OBJ_ZSET_MAX_ZIPLIST_VALUE ; server . hll_sparse_max_bytes = CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES ; server . shutdown_asap = <int> ; server . cluster_enabled = <int> ; server . cluster_node_timeout = CLUSTER_DEFAULT_NODE_TIMEOUT ; server . cluster_migration_barrier = CLUSTER_DEFAULT_MIGRATION_BARRIER ; server . cluster_slave_validity_factor = CLUSTER_DEFAULT_SLAVE_VALIDITY ; server . cluster_require_full_coverage = CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE ; server . cluster_configfile = zstrdup ( CONFIG_DEFAULT_CLUSTER_CONFIG_FILE ) ; server . cluster_announce_ip = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP ; server . cluster_announce_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT ; server . cluster_announce_bus_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT ; server . migrate_cached_sockets = dictCreate ( & migrateCacheDictType , NULL ) ; server . next_client_id = <int> ; server . loading_process_events_interval_bytes = ( <int> * <int> * <int> ) ; server . lazyfree_lazy_eviction = CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION ; server . lazyfree_lazy_expire = CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE ; server . lazyfree_lazy_server_del = CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL ; server . lruclock = getLRUClock ( ) ; resetServerSaveParams ( ) ; appendServerSaveParams ( <int> * <int> , <int> ) ; appendServerSaveParams ( <int> , <int> ) ; appendServerSaveParams ( <int> , <int> ) ; server . masterauth = NULL ; server . masterhost = NULL ; server . masterport = <int> ; server . master = NULL ; server . cached_master = NULL ; server . repl_master_initial_offset = - <int> ; server . repl_state = REPL_STATE_NONE ; server . repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT ; server . repl_serve_stale_data = CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA ; server . repl_slave_ro = CONFIG_DEFAULT_SLAVE_READ_ONLY ; server . repl_slave_lazy_flush = CONFIG_DEFAULT_SLAVE_LAZY_FLUSH ; server . repl_down_since = <int> ; server . repl_disable_tcp_nodelay = CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY ; server . repl_diskless_sync = CONFIG_DEFAULT_REPL_DISKLESS_SYNC ; server . repl_diskless_sync_delay = CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY ; server . repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD ; server . repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT ; server . repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE ; server . repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG ; server . slave_priority = CONFIG_DEFAULT_SLAVE_PRIORITY ; server . master_repl_offset = <int> ; server . repl_backlog = NULL ; server . repl_backlog_size = CONFIG_DEFAULT_REPL_BACKLOG_SIZE ; server . repl_backlog_histlen = <int> ; server . repl_backlog_idx = <int> ; server . repl_backlog_off = <int> ; server . repl_backlog_time_limit = CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT ; server . repl_no_slaves_since = time ( NULL ) ; for ( j = <int> ; j < CLIENT_TYPE_OBUF_COUNT ; j + + ) server . client_obuf_limits [ j ] = clientBufferLimitsDefaults [ j ] ; R_Zero = <float> ; R_PosInf = <float> / R_Zero ; R_NegInf = - <float> / R_Zero ; R_Nan = R_Zero / R_Zero ; 
