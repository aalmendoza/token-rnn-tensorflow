unsigned int lzf_compress ( const void * const in_data , unsigned int in_len , void * out_data , unsigned int out_len , LZF_STATE htab ) { LZF_STATE htab ; const u8 * ip = ( const u8 * ) in_data ; u8 * op = ( u8 * ) out_data ; const u8 * in_end = ip + in_len ; u8 * out_end = op + out_len ; const u8 * ref ; unsigned _int64 off ; unsigned long off ; unsigned int hval ; int lit ; if ( ! in_len | | ! out_len ) return <int> ; memset ( htab , <int> , sizeof ( htab ) ) ; lit = <int> ; op + + ; hval = FRST ( ip ) ; while ( ip < in_end - <int> ) { LZF_HSLOT * hslot ; hval = NEXT ( hval , ip ) ; hslot = htab + IDX ( hval ) ; ref = * hslot + LZF_HSLOT_BIAS ; * hslot = ip - LZF_HSLOT_BIAS ; if ( <int> & & ref < ip & & ( off = ip - ref - <int> ) < MAX_OFF & & ref > ( u8 * ) in_data & & ref [ <int> ] = = ip [ <int> ] & & ( ( ref [ <int> ] < < <int> ) | ref [ <int> ] ) = = ( ( ip [ <int> ] < < <int> ) | ip [ <int> ] ) & & * ( u16 * ) ref = = * ( u16 * ) ip ) { unsigned int len = <int> ; unsigned int maxlen = in_end - ip - len ; maxlen = maxlen > MAX_REF ? MAX_REF : maxlen ; if ( expect_false ( op + <int> + <int> > = out_end ) ) if ( op - ! lit + <int> + <int> > = out_end ) return <int> ; op [ - lit - <int> ] = lit - <int> ; op - = ! lit ; for ( ; ; ) { if ( expect_true ( maxlen > <int> ) ) { len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; len + + ; if ( ref [ len ] ! = ip [ len ] ) break ; } do len + + ; while ( len < maxlen & & ref [ len ] = = ip [ len ] ) ; break ; } len - = <int> ; ip + + ; if ( len < <int> ) { * op + + = ( off > > <int> ) + ( len < < <int> ) ; } else { * op + + = ( off > > <int> ) + ( <int> < < <int> ) ; * op + + = len - <int> ; } * op + + = off ; lit = <int> ; op + + ; ip + = len + <int> ; if ( expect_false ( ip > = in_end - <int> ) ) break ; - - ip ; - - ip ; hval = FRST ( ip ) ; hval = NEXT ( hval , ip ) ; htab [ IDX ( hval ) ] = ip - LZF_HSLOT_BIAS ; ip + + ; hval = NEXT ( hval , ip ) ; htab [ IDX ( hval ) ] = ip - LZF_HSLOT_BIAS ; ip + + ; ip - = len + <int> ; do { hval = NEXT ( hval , ip ) ; htab [ IDX ( hval ) ] = ip - LZF_HSLOT_BIAS ; ip + + ; } while ( len - - ) ; } else { if ( expect_false ( op > = out_end ) ) return <int> ; lit + + ; * op + + = * ip + + ; if ( expect_false ( lit = = MAX_LIT ) ) { op [ - lit - <int> ] = lit - <int> ; lit = <int> ; op + + ; } } } if ( op + <int> > out_end ) return <int> ; while ( ip < in_end ) { lit + + ; * op + + = * ip + + ; if ( expect_false ( lit = = MAX_LIT ) ) { op [ - lit - <int> ] = lit - <int> ; lit = <int> ; op + + ; } } op [ - lit - <int> ] = lit - <int> ; op - = ! lit ; return op - ( u8 * ) out_data ; } 
