void hashTypeTryConversion ( robj * o , robj * * argv , int start , int end ) { int i ; if ( o - > encoding ! = OBJ_ENCODING_ZIPLIST ) return ; for ( i = start ; i < = end ; i + + ) { if ( sdsEncodedObject ( argv [ i ] ) & & sdslen ( argv [ i ] - > ptr ) > server . hash_max_ziplist_value ) { hashTypeConvert ( o , OBJ_ENCODING_HT ) ; break ; } } } int hashTypeGetFromZiplist ( robj * o , sds field , unsigned char * * vstr , unsigned int * vlen , long long * vll ) { unsigned char * zl , * fptr = NULL , * vptr = NULL ; int ret ; serverAssert ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) ; zl = o - > ptr ; fptr = ziplistIndex ( zl , ZIPLIST_HEAD ) ; if ( fptr ! = NULL ) { fptr = ziplistFind ( fptr , ( unsigned char * ) field , sdslen ( field ) , <int> ) ; if ( fptr ! = NULL ) { vptr = ziplistNext ( zl , fptr ) ; serverAssert ( vptr ! = NULL ) ; } } if ( vptr ! = NULL ) { ret = ziplistGet ( vptr , vstr , vlen , vll ) ; serverAssert ( ret ) ; return <int> ; } return - <int> ; } sds hashTypeGetFromHashTable ( robj * o , sds field ) { dictEntry * de ; serverAssert ( o - > encoding = = OBJ_ENCODING_HT ) ; de = dictFind ( o - > ptr , field ) ; if ( de = = NULL ) return NULL ; return dictGetVal ( de ) ; } int hashTypeGetValue ( robj * o , sds field , unsigned char * * vstr , unsigned int * vlen , long long * vll ) { if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { * vstr = NULL ; if ( hashTypeGetFromZiplist ( o , field , vstr , vlen , vll ) = = <int> ) return C_OK ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { sds value ; if ( ( value = hashTypeGetFromHashTable ( o , field ) ) ! = NULL ) { * vstr = ( unsigned char * ) value ; * vlen = sdslen ( value ) ; return C_OK ; } } else { serverPanic ( <str> ) ; } return C_ERR ; } robj * hashTypeGetValueObject ( robj * o , sds field ) { unsigned char * vstr ; unsigned int vlen ; long long vll ; if ( hashTypeGetValue ( o , field , & vstr , & vlen , & vll ) = = C_ERR ) return NULL ; if ( vstr ) return createStringObject ( ( char * ) vstr , vlen ) ; else return createStringObjectFromLongLong ( vll ) ; } size_t hashTypeGetValueLength ( robj * o , sds field ) { size_t len = <int> ; if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * vstr = NULL ; unsigned int vlen = UINT_MAX ; long long vll = LLONG_MAX ; if ( hashTypeGetFromZiplist ( o , field , & vstr , & vlen , & vll ) = = <int> ) len = vstr ? vlen : sdigits10 ( vll ) ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { sds aux ; if ( ( aux = hashTypeGetFromHashTable ( o , field ) ) ! = NULL ) len = sdslen ( aux ) ; } else { serverPanic ( <str> ) ; } return len ; } int hashTypeExists ( robj * o , sds field ) { if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * vstr = NULL ; unsigned int vlen = UINT_MAX ; long long vll = LLONG_MAX ; if ( hashTypeGetFromZiplist ( o , field , & vstr , & vlen , & vll ) = = <int> ) return <int> ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { if ( hashTypeGetFromHashTable ( o , field ) ! = NULL ) return <int> ; } else { serverPanic ( <str> ) ; } return <int> ; } int hashTypeSet ( robj * o , sds field , sds value , int flags ) { int update = <int> ; if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * zl , * fptr , * vptr ; zl = o - > ptr ; fptr = ziplistIndex ( zl , ZIPLIST_HEAD ) ; if ( fptr ! = NULL ) { fptr = ziplistFind ( fptr , ( unsigned char * ) field , sdslen ( field ) , <int> ) ; if ( fptr ! = NULL ) { vptr = ziplistNext ( zl , fptr ) ; serverAssert ( vptr ! = NULL ) ; update = <int> ; zl = ziplistDelete ( zl , & vptr ) ; zl = ziplistInsert ( zl , vptr , ( unsigned char * ) value , sdslen ( value ) ) ; } } if ( ! update ) { zl = ziplistPush ( zl , ( unsigned char * ) field , sdslen ( field ) , ZIPLIST_TAIL ) ; zl = ziplistPush ( zl , ( unsigned char * ) value , sdslen ( value ) , ZIPLIST_TAIL ) ; } o - > ptr = zl ; if ( hashTypeLength ( o ) > server . hash_max_ziplist_entries ) hashTypeConvert ( o , OBJ_ENCODING_HT ) ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { dictEntry * de = dictFind ( o - > ptr , field ) ; if ( de ) { sdsfree ( dictGetVal ( de ) ) ; if ( flags & HASH_SET_TAKE_VALUE ) { dictGetVal ( de ) = value ; value = NULL ; } else { dictGetVal ( de ) = sdsdup ( value ) ; } update = <int> ; } else { sds f , v ; if ( flags & HASH_SET_TAKE_FIELD ) { f = field ; field = NULL ; } else { f = sdsdup ( field ) ; } if ( flags & HASH_SET_TAKE_VALUE ) { v = value ; value = NULL ; } else { v = sdsdup ( value ) ; } dictAdd ( o - > ptr , f , v ) ; } } else { serverPanic ( <str> ) ; } if ( flags & HASH_SET_TAKE_FIELD & & field ) sdsfree ( field ) ; if ( flags & HASH_SET_TAKE_VALUE & & value ) sdsfree ( value ) ; return update ; } int hashTypeDelete ( robj * o , sds field ) { int deleted = <int> ; if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * zl , * fptr ; zl = o - > ptr ; fptr = ziplistIndex ( zl , ZIPLIST_HEAD ) ; if ( fptr ! = NULL ) { fptr = ziplistFind ( fptr , ( unsigned char * ) field , sdslen ( field ) , <int> ) ; if ( fptr ! = NULL ) { zl = ziplistDelete ( zl , & fptr ) ; zl = ziplistDelete ( zl , & fptr ) ; o - > ptr = zl ; deleted = <int> ; } } } else if ( o - > encoding = = OBJ_ENCODING_HT ) { if ( dictDelete ( ( dict * ) o - > ptr , field ) = = C_OK ) { deleted = <int> ; if ( htNeedsResize ( o - > ptr ) ) dictResize ( o - > ptr ) ; } } else { serverPanic ( <str> ) ; } return deleted ; } unsigned long hashTypeLength ( robj * o ) { unsigned long length = ULONG_MAX ; if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { length = ziplistLen ( o - > ptr ) / <int> ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { length = dictSize ( ( dict * ) o - > ptr ) ; } else { serverPanic ( <str> ) ; } return length ; } hashTypeIterator * hashTypeInitIterator ( robj * subject ) { hashTypeIterator * hi = zmalloc ( sizeof ( hashTypeIterator ) ) ; hi - > subject = subject ; hi - > encoding = subject - > encoding ; if ( hi - > encoding = = OBJ_ENCODING_ZIPLIST ) { hi - > fptr = NULL ; hi - > vptr = NULL ; } else if ( hi - > encoding = = OBJ_ENCODING_HT ) { hi - > di = dictGetIterator ( subject - > ptr ) ; } else { serverPanic ( <str> ) ; } return hi ; } void hashTypeReleaseIterator ( hashTypeIterator * hi ) { if ( hi - > encoding = = OBJ_ENCODING_HT ) dictReleaseIterator ( hi - > di ) ; zfree ( hi ) ; } int hashTypeNext ( hashTypeIterator * hi ) { if ( hi - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * zl ; unsigned char * fptr , * vptr ; zl = hi - > subject - > ptr ; fptr = hi - > fptr ; vptr = hi - > vptr ; if ( fptr = = NULL ) { serverAssert ( vptr = = NULL ) ; fptr = ziplistIndex ( zl , <int> ) ; } else { serverAssert ( vptr ! = NULL ) ; fptr = ziplistNext ( zl , vptr ) ; } if ( fptr = = NULL ) return C_ERR ; vptr = ziplistNext ( zl , fptr ) ; serverAssert ( vptr ! = NULL ) ; hi - > fptr = fptr ; hi - > vptr = vptr ; } else if ( hi - > encoding = = OBJ_ENCODING_HT ) { if ( ( hi - > de = dictNext ( hi - > di ) ) = = NULL ) return C_ERR ; } else { serverPanic ( <str> ) ; } return C_OK ; } void hashTypeCurrentFromZiplist ( hashTypeIterator * hi , int what , unsigned char * * vstr , unsigned int * vlen , long long * vll ) { int ret ; serverAssert ( hi - > encoding = = OBJ_ENCODING_ZIPLIST ) ; if ( what & OBJ_HASH_KEY ) { ret = ziplistGet ( hi - > fptr , vstr , vlen , vll ) ; serverAssert ( ret ) ; } else { ret = ziplistGet ( hi - > vptr , vstr , vlen , vll ) ; serverAssert ( ret ) ; } } sds hashTypeCurrentFromHashTable ( hashTypeIterator * hi , int what ) { serverAssert ( hi - > encoding = = OBJ_ENCODING_HT ) ; if ( what & OBJ_HASH_KEY ) { return dictGetKey ( hi - > de ) ; } else { return dictGetVal ( hi - > de ) ; } } void hashTypeCurrentObject ( hashTypeIterator * hi , int what , unsigned char * * vstr , unsigned int * vlen , long long * vll ) { if ( hi - > encoding = = OBJ_ENCODING_ZIPLIST ) { * vstr = NULL ; hashTypeCurrentFromZiplist ( hi , what , vstr , vlen , vll ) ; } else if ( hi - > encoding = = OBJ_ENCODING_HT ) { sds ele = hashTypeCurrentFromHashTable ( hi , what ) ; * vstr = ( unsigned char * ) ele ; * vlen = sdslen ( ele ) ; } else { serverPanic ( <str> ) ; } } sds hashTypeCurrentObjectNewSds ( hashTypeIterator * hi , int what ) { unsigned char * vstr ; unsigned int vlen ; long long vll ; hashTypeCurrentObject ( hi , what , & vstr , & vlen , & vll ) ; if ( vstr ) return sdsnewlen ( vstr , vlen ) ; return sdsfromlonglong ( vll ) ; } robj * hashTypeLookupWriteOrCreate ( client * c , robj * key ) { robj * o = lookupKeyWrite ( c - > db , key ) ; if ( o = = NULL ) { o = createHashObject ( ) ; dbAdd ( c - > db , key , o ) ; } else { if ( o - > type ! = OBJ_HASH ) { addReply ( c , shared . wrongtypeerr ) ; return NULL ; } } return o ; } void hashTypeConvertZiplist ( robj * o , int enc ) { serverAssert ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) ; if ( enc = = OBJ_ENCODING_ZIPLIST ) { } else if ( enc = = OBJ_ENCODING_HT ) { hashTypeIterator * hi ; dict * dict ; int ret ; hi = hashTypeInitIterator ( o ) ; dict = dictCreate ( & hashDictType , NULL ) ; while ( hashTypeNext ( hi ) ! = C_ERR ) { sds key , value ; key = hashTypeCurrentObjectNewSds ( hi , OBJ_HASH_KEY ) ; value = hashTypeCurrentObjectNewSds ( hi , OBJ_HASH_VALUE ) ; ret = dictAdd ( dict , key , value ) ; if ( ret ! = DICT_OK ) { serverLogHexDump ( LL_WARNING , <str> , o - > ptr , ziplistBlobLen ( o - > ptr ) ) ; serverPanic ( <str> ) ; } } hashTypeReleaseIterator ( hi ) ; zfree ( o - > ptr ) ; o - > encoding = OBJ_ENCODING_HT ; o - > ptr = dict ; } else { serverPanic ( <str> ) ; } } void hashTypeConvert ( robj * o , int enc ) { if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { hashTypeConvertZiplist ( o , enc ) ; } else if ( o - > encoding = = OBJ_ENCODING_HT ) { serverPanic ( <str> ) ; } else { serverPanic ( <str> ) ; } } void hsetCommand ( client * c ) { int update ; robj * o ; if ( ( o = hashTypeLookupWriteOrCreate ( c , c - > argv [ <int> ] ) ) = = NULL ) return ; hashTypeTryConversion ( o , c - > argv , <int> , <int> ) ; update = hashTypeSet ( o , c - > argv [ <int> ] - > ptr , c - > argv [ <int> ] - > ptr , HASH_SET_COPY ) ; addReply ( c , update ? shared . czero : shared . cone ) ; signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + + ; } void hsetnxCommand ( client * c ) { robj * o ; if ( ( o = hashTypeLookupWriteOrCreate ( c , c - > argv [ <int> ] ) ) = = NULL ) return ; hashTypeTryConversion ( o , c - > argv , <int> , <int> ) ; if ( hashTypeExists ( o , c - > argv [ <int> ] - > ptr ) ) { addReply ( c , shared . czero ) ; } else { hashTypeSet ( o , c - > argv [ <int> ] - > ptr , c - > argv [ <int> ] - > ptr , HASH_SET_COPY ) ; addReply ( c , shared . cone ) ; signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + + ; } } void hmsetCommand ( client * c ) { int i ; robj * o ; if ( ( c - > argc % <int> ) = = <int> ) { addReplyError ( c , <str> ) ; return ; } if ( ( o = hashTypeLookupWriteOrCreate ( c , c - > argv [ <int> ] ) ) = = NULL ) return ; hashTypeTryConversion ( o , c - > argv , <int> , c - > argc - <int> ) ; for ( i = <int> ; i < c - > argc ; i + = <int> ) { hashTypeSet ( o , c - > argv [ i ] - > ptr , c - > argv [ i + <int> ] - > ptr , HASH_SET_COPY ) ; } addReply ( c , shared . ok ) ; signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + + ; } void hincrbyCommand ( client * c ) { long long value , incr , oldvalue ; robj * o ; sds new ; unsigned char * vstr ; unsigned int vlen ; if ( getLongLongFromObjectOrReply ( c , c - > argv [ <int> ] , & incr , NULL ) ! = C_OK ) return ; if ( ( o = hashTypeLookupWriteOrCreate ( c , c - > argv [ <int> ] ) ) = = NULL ) return ; if ( hashTypeGetValue ( o , c - > argv [ <int> ] - > ptr , & vstr , & vlen , & value ) = = C_OK ) { if ( vstr ) { if ( string2ll ( ( char * ) vstr , vlen , & value ) = = <int> ) { addReplyError ( c , <str> ) ; return ; } } } else { value = <int> ; } oldvalue = value ; if ( ( incr < <int> & & oldvalue < <int> & & incr < ( LLONG_MIN - oldvalue ) ) | | ( incr > <int> & & oldvalue > <int> & & incr > ( LLONG_MAX - oldvalue ) ) ) { addReplyError ( c , <str> ) ; return ; } value + = incr ; new = sdsfromlonglong ( value ) ; hashTypeSet ( o , c - > argv [ <int> ] - > ptr , new , HASH_SET_TAKE_VALUE ) ; addReplyLongLong ( c , value ) ; signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + + ; } void hincrbyfloatCommand ( client * c ) { long double value , incr ; long long ll ; robj * o ; sds new ; unsigned char * vstr ; unsigned int vlen ; if ( getLongDoubleFromObjectOrReply ( c , c - > argv [ <int> ] , & incr , NULL ) ! = C_OK ) return ; if ( ( o = hashTypeLookupWriteOrCreate ( c , c - > argv [ <int> ] ) ) = = NULL ) return ; if ( hashTypeGetValue ( o , c - > argv [ <int> ] - > ptr , & vstr , & vlen , & ll ) = = C_OK ) { if ( vstr ) { if ( string2ld ( ( char * ) vstr , vlen , & value ) = = <int> ) { addReplyError ( c , <str> ) ; return ; } } else { value = ( long double ) ll ; } } else { value = <int> ; } value + = incr ; char buf [ <int> ] ; int len = ld2string ( buf , sizeof ( buf ) , value , <int> ) ; new = sdsnewlen ( buf , len ) ; hashTypeSet ( o , c - > argv [ <int> ] - > ptr , new , HASH_SET_TAKE_VALUE ) ; addReplyBulkCBuffer ( c , buf , len ) ; signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + + ; robj * aux , * newobj ; aux = createStringObject ( <str> , <int> ) ; newobj = createRawStringObject ( buf , len ) ; rewriteClientCommandArgument ( c , <int> , aux ) ; decrRefCount ( aux ) ; rewriteClientCommandArgument ( c , <int> , newobj ) ; decrRefCount ( newobj ) ; } static void addHashFieldToReply ( client * c , robj * o , sds field ) { int ret ; if ( o = = NULL ) { addReply ( c , shared . nullbulk ) ; return ; } if ( o - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * vstr = NULL ; unsigned int vlen = UINT_MAX ; long long vll = LLONG_MAX ; ret = hashTypeGetFromZiplist ( o , field , & vstr , & vlen , & vll ) ; if ( ret < <int> ) { addReply ( c , shared . nullbulk ) ; } else { if ( vstr ) { addReplyBulkCBuffer ( c , vstr , vlen ) ; } else { addReplyBulkLongLong ( c , vll ) ; } } } else if ( o - > encoding = = OBJ_ENCODING_HT ) { sds value = hashTypeGetFromHashTable ( o , field ) ; if ( value = = NULL ) addReply ( c , shared . nullbulk ) ; else addReplyBulkCBuffer ( c , value , sdslen ( value ) ) ; } else { serverPanic ( <str> ) ; } } void hgetCommand ( client * c ) { robj * o ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . nullbulk ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; addHashFieldToReply ( c , o , c - > argv [ <int> ] - > ptr ) ; } void hmgetCommand ( client * c ) { robj * o ; int i ; o = lookupKeyRead ( c - > db , c - > argv [ <int> ] ) ; if ( o ! = NULL & & o - > type ! = OBJ_HASH ) { addReply ( c , shared . wrongtypeerr ) ; return ; } addReplyMultiBulkLen ( c , c - > argc - <int> ) ; for ( i = <int> ; i < c - > argc ; i + + ) { addHashFieldToReply ( c , o , c - > argv [ i ] - > ptr ) ; } } void hdelCommand ( client * c ) { robj * o ; int j , deleted = <int> , keyremoved = <int> ; if ( ( o = lookupKeyWriteOrReply ( c , c - > argv [ <int> ] , shared . czero ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; for ( j = <int> ; j < c - > argc ; j + + ) { if ( hashTypeDelete ( o , c - > argv [ j ] - > ptr ) ) { deleted + + ; if ( hashTypeLength ( o ) = = <int> ) { dbDelete ( c - > db , c - > argv [ <int> ] ) ; keyremoved = <int> ; break ; } } } if ( deleted ) { signalModifiedKey ( c - > db , c - > argv [ <int> ] ) ; notifyKeyspaceEvent ( NOTIFY_HASH , <str> , c - > argv [ <int> ] , c - > db - > id ) ; if ( keyremoved ) notifyKeyspaceEvent ( NOTIFY_GENERIC , <str> , c - > argv [ <int> ] , c - > db - > id ) ; server . dirty + = deleted ; } addReplyLongLong ( c , deleted ) ; } void hlenCommand ( client * c ) { robj * o ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . czero ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; addReplyLongLong ( c , hashTypeLength ( o ) ) ; } void hstrlenCommand ( client * c ) { robj * o ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . czero ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; addReplyLongLong ( c , hashTypeGetValueLength ( o , c - > argv [ <int> ] - > ptr ) ) ; } static void addHashIteratorCursorToReply ( client * c , hashTypeIterator * hi , int what ) { if ( hi - > encoding = = OBJ_ENCODING_ZIPLIST ) { unsigned char * vstr = NULL ; unsigned int vlen = UINT_MAX ; long long vll = LLONG_MAX ; hashTypeCurrentFromZiplist ( hi , what , & vstr , & vlen , & vll ) ; if ( vstr ) addReplyBulkCBuffer ( c , vstr , vlen ) ; else addReplyBulkLongLong ( c , vll ) ; } else if ( hi - > encoding = = OBJ_ENCODING_HT ) { sds value = hashTypeCurrentFromHashTable ( hi , what ) ; addReplyBulkCBuffer ( c , value , sdslen ( value ) ) ; } else { serverPanic ( <str> ) ; } } void genericHgetallCommand ( client * c , int flags ) { robj * o ; hashTypeIterator * hi ; int multiplier = <int> ; int length , count = <int> ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . emptymultibulk ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; if ( flags & OBJ_HASH_KEY ) multiplier + + ; if ( flags & OBJ_HASH_VALUE ) multiplier + + ; length = hashTypeLength ( o ) * multiplier ; addReplyMultiBulkLen ( c , length ) ; hi = hashTypeInitIterator ( o ) ; while ( hashTypeNext ( hi ) ! = C_ERR ) { if ( flags & OBJ_HASH_KEY ) { addHashIteratorCursorToReply ( c , hi , OBJ_HASH_KEY ) ; count + + ; } if ( flags & OBJ_HASH_VALUE ) { addHashIteratorCursorToReply ( c , hi , OBJ_HASH_VALUE ) ; count + + ; } } hashTypeReleaseIterator ( hi ) ; serverAssert ( count = = length ) ; } void hkeysCommand ( client * c ) { genericHgetallCommand ( c , OBJ_HASH_KEY ) ; } void hvalsCommand ( client * c ) { genericHgetallCommand ( c , OBJ_HASH_VALUE ) ; } void hgetallCommand ( client * c ) { genericHgetallCommand ( c , OBJ_HASH_KEY | OBJ_HASH_VALUE ) ; } void hexistsCommand ( client * c ) { robj * o ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . czero ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; addReply ( c , hashTypeExists ( o , c - > argv [ <int> ] - > ptr ) ? shared . cone : shared . czero ) ; } void hscanCommand ( client * c ) { robj * o ; unsigned long cursor ; if ( parseScanCursorOrReply ( c , c - > argv [ <int> ] , & cursor ) = = C_ERR ) return ; if ( ( o = lookupKeyReadOrReply ( c , c - > argv [ <int> ] , shared . emptyscan ) ) = = NULL | | checkType ( c , o , OBJ_HASH ) ) return ; scanGenericCommand ( c , o , cursor ) ; } 
