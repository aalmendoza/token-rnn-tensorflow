static pthread_t bio_threads [ BIO_NUM_OPS ] ; static pthread_mutex_t bio_mutex [ BIO_NUM_OPS ] ; static pthread_cond_t bio_newjob_cond [ BIO_NUM_OPS ] ; static pthread_cond_t bio_step_cond [ BIO_NUM_OPS ] ; static list * bio_jobs [ BIO_NUM_OPS ] ; static unsigned long long bio_pending [ BIO_NUM_OPS ] ; struct bio_job { time_t time ; void * arg1 , * arg2 , * arg3 ; } ; void * bioProcessBackgroundJobs ( void * arg ) ; void lazyfreeFreeObjectFromBioThread ( robj * o ) ; void lazyfreeFreeDatabaseFromBioThread ( dict * ht1 , dict * ht2 ) ; void lazyfreeFreeSlotsMapFromBioThread ( zskiplist * sl ) ; void bioInit ( void ) { pthread_attr_t attr ; pthread_t thread ; size_t stacksize ; int j ; for ( j = <int> ; j < BIO_NUM_OPS ; j + + ) { pthread_mutex_init ( & bio_mutex [ j ] , NULL ) ; pthread_cond_init ( & bio_newjob_cond [ j ] , NULL ) ; pthread_cond_init ( & bio_step_cond [ j ] , NULL ) ; bio_jobs [ j ] = listCreate ( ) ; bio_pending [ j ] = <int> ; } pthread_attr_init ( & attr ) ; pthread_attr_getstacksize ( & attr , & stacksize ) ; if ( ! stacksize ) stacksize = <int> ; while ( stacksize < REDIS_THREAD_STACK_SIZE ) stacksize * = <int> ; pthread_attr_setstacksize ( & attr , stacksize ) ; for ( j = <int> ; j < BIO_NUM_OPS ; j + + ) { void * arg = ( void * ) ( unsigned long ) j ; if ( pthread_create ( & thread , & attr , bioProcessBackgroundJobs , arg ) ! = <int> ) { serverLog ( LL_WARNING , <str> ) ; exit ( <int> ) ; } bio_threads [ j ] = thread ; } } void bioCreateBackgroundJob ( int type , void * arg1 , void * arg2 , void * arg3 ) { struct bio_job * job = zmalloc ( sizeof ( * job ) ) ; job - > time = time ( NULL ) ; job - > arg1 = arg1 ; job - > arg2 = arg2 ; job - > arg3 = arg3 ; pthread_mutex_lock ( & bio_mutex [ type ] ) ; listAddNodeTail ( bio_jobs [ type ] , job ) ; bio_pending [ type ] + + ; pthread_cond_signal ( & bio_newjob_cond [ type ] ) ; pthread_mutex_unlock ( & bio_mutex [ type ] ) ; } void * bioProcessBackgroundJobs ( void * arg ) { struct bio_job * job ; unsigned long type = ( unsigned long ) arg ; sigset_t sigset ; if ( type > = BIO_NUM_OPS ) { serverLog ( LL_WARNING , <str> , type ) ; return NULL ; } pthread_setcancelstate ( PTHREAD_CANCEL_ENABLE , NULL ) ; pthread_setcanceltype ( PTHREAD_CANCEL_ASYNCHRONOUS , NULL ) ; pthread_mutex_lock ( & bio_mutex [ type ] ) ; sigemptyset ( & sigset ) ; sigaddset ( & sigset , SIGALRM ) ; if ( pthread_sigmask ( SIG_BLOCK , & sigset , NULL ) ) serverLog ( LL_WARNING , <str> , strerror ( errno ) ) ; while ( <int> ) { listNode * ln ; if ( listLength ( bio_jobs [ type ] ) = = <int> ) { pthread_cond_wait ( & bio_newjob_cond [ type ] , & bio_mutex [ type ] ) ; continue ; } ln = listFirst ( bio_jobs [ type ] ) ; job = ln - > value ; pthread_mutex_unlock ( & bio_mutex [ type ] ) ; if ( type = = BIO_CLOSE_FILE ) { close ( ( long ) job - > arg1 ) ; } else if ( type = = BIO_AOF_FSYNC ) { aof_fsync ( ( long ) job - > arg1 ) ; } else if ( type = = BIO_LAZY_FREE ) { if ( job - > arg1 ) lazyfreeFreeObjectFromBioThread ( job - > arg1 ) ; else if ( job - > arg2 & & job - > arg3 ) lazyfreeFreeDatabaseFromBioThread ( job - > arg2 , job - > arg3 ) ; else if ( job - > arg3 ) lazyfreeFreeSlotsMapFromBioThread ( job - > arg3 ) ; } else { serverPanic ( <str> ) ; } zfree ( job ) ; pthread_cond_broadcast ( & bio_step_cond [ type ] ) ; pthread_mutex_lock ( & bio_mutex [ type ] ) ; listDelNode ( bio_jobs [ type ] , ln ) ; bio_pending [ type ] - - ; } } unsigned long long bioPendingJobsOfType ( int type ) { unsigned long long val ; pthread_mutex_lock ( & bio_mutex [ type ] ) ; val = bio_pending [ type ] ; pthread_mutex_unlock ( & bio_mutex [ type ] ) ; return val ; } unsigned long long bioWaitStepOfType ( int type ) { unsigned long long val ; pthread_mutex_lock ( & bio_mutex [ type ] ) ; val = bio_pending [ type ] ; if ( val ! = <int> ) { pthread_cond_wait ( & bio_step_cond [ type ] , & bio_mutex [ type ] ) ; val = bio_pending [ type ] ; } pthread_mutex_unlock ( & bio_mutex [ type ] ) ; return val ; } void bioKillThreads ( void ) { int err , j ; for ( j = <int> ; j < BIO_NUM_OPS ; j + + ) { if ( pthread_cancel ( bio_threads [ j ] ) = = <int> ) { if ( ( err = pthread_join ( bio_threads [ j ] , NULL ) ) ! = <int> ) { serverLog ( LL_WARNING , <str> , j , strerror ( err ) ) ; } else { serverLog ( LL_WARNING , <str> , j ) ; } } } } 
