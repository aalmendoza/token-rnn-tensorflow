<START>
struct
sharedObjectsStruct
shared
;
double
R_Zero
,
R_PosInf
,
R_NegInf
,
R_Nan
;
struct
redisServer
server
;
struct
redisCommand
redisCommandTable
[
]
=
{
{
<str>
,
getCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
setCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
setnxCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
setexCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
psetexCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
appendCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
strlenCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
delCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
unlinkCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
existsCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
setbitCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
getbitCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bitfieldCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
setrangeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
getrangeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
getrangeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
incrCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
decrCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
mgetCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
rpushCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lpushCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
rpushxCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lpushxCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
linsertCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
rpopCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lpopCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
brpopCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
brpoplpushCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
blpopCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
llenCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lindexCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lsetCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lrangeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
ltrimCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lremCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
rpoplpushCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
saddCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sremCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
smoveCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sismemberCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
scardCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
spopCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
srandmemberCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sinterCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sinterstoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sunionCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sunionstoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sdiffCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sdiffstoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sinterCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sscanCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zaddCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zincrbyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zremCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zremrangebyscoreCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zremrangebyrankCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zremrangebylexCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zunionstoreCommand
,
-
<int>
,
<str>
,
<int>
,
zunionInterGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zinterstoreCommand
,
-
<int>
,
<str>
,
<int>
,
zunionInterGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrangeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrangebyscoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrevrangebyscoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrangebylexCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrevrangebylexCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zcountCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zlexcountCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrevrangeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zcardCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zscoreCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrankCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zrevrankCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
zscanCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hsetCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hsetnxCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hgetCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hmsetCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hmgetCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hincrbyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hincrbyfloatCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hdelCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hlenCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hstrlenCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hkeysCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hvalsCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hgetallCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hexistsCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
hscanCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
incrbyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
decrbyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
incrbyfloatCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
getsetCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
msetCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
msetnxCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
randomkeyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
selectCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
moveCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
renameCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
renamenxCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
expireCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
expireatCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pexpireCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pexpireatCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
keysCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
scanCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
dbsizeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
authCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pingCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
echoCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
saveCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bgsaveCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bgrewriteaofCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
shutdownCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
lastsaveCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
typeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
multiCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
execCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
discardCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
syncCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
syncCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
replconfCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
flushdbCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
flushallCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
sortCommand
,
-
<int>
,
<str>
,
<int>
,
sortGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
infoCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
monitorCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
ttlCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pttlCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
persistCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
slaveofCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
roleCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
debugCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
configCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
subscribeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
unsubscribeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
psubscribeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
punsubscribeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
publishCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pubsubCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
watchCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
unwatchCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
clusterCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
restoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
restoreCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
migrateCommand
,
-
<int>
,
<str>
,
<int>
,
migrateGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
askingCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
readonlyCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
readwriteCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
dumpCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
objectCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
clientCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
evalCommand
,
-
<int>
,
<str>
,
<int>
,
evalGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
evalShaCommand
,
-
<int>
,
<str>
,
<int>
,
evalGetKeys
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
slowlogCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
scriptCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
timeCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bitopCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bitcountCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
bitposCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
waitCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
commandCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
geoaddCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
georadiusCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
georadiusByMemberCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
geohashCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
geoposCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
geodistCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pfselftestCommand
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pfaddCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pfcountCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pfmergeCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
pfdebugCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
latencyCommand
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
}
;
struct
evictionPoolEntry
*
evictionPoolAlloc
(
void
)
;
void
serverLogRaw
(
int
level
,
const
char
*
msg
)
{
const
int
syslogLevelMap
[
]
=
{
LOG_DEBUG
,
LOG_INFO
,
LOG_NOTICE
,
LOG_WARNING
}
;
const
char
*
c
=
<str>
;
FILE
*
fp
;
char
buf
[
<int>
]
;
int
rawmode
=
(
level
&
LL_RAW
)
;
int
log_to_stdout
=
server
.
logfile
[
<int>
]
=
=
<str>
;
level
&
=
<hex>
;
if
(
level
<
server
.
verbosity
)
return
;
fp
=
log_to_stdout
?
stdout
:
fopen
(
server
.
logfile
,
<str>
)
;
if
(
!
fp
)
return
;
if
(
rawmode
)
{
fprintf
(
fp
,
<str>
,
msg
)
;
}
else
{
int
off
;
struct
timeval
tv
;
int
role_char
;
pid_t
pid
=
getpid
(
)
;
gettimeofday
(
&
tv
,
NULL
)
;
off
=
strftime
(
buf
,
sizeof
(
buf
)
,
<str>
,
localtime
(
&
tv
.
tv_sec
)
)
;
snprintf
(
buf
+
off
,
sizeof
(
buf
)
-
off
,
<str>
,
(
int
)
tv
.
tv_usec
/
<int>
)
;
if
(
server
.
sentinel_mode
)
{
role_char
=
<str>
;
}
else
if
(
pid
!
=
server
.
pid
)
{
role_char
=
<str>
;
}
else
{
role_char
=
(
server
.
masterhost
?
<str>
:
<str>
)
;
}
fprintf
(
fp
,
<str>
,
(
int
)
getpid
(
)
,
role_char
,
buf
,
c
[
level
]
,
msg
)
;
}
fflush
(
fp
)
;
if
(
!
log_to_stdout
)
fclose
(
fp
)
;
if
(
server
.
syslog_enabled
)
syslog
(
syslogLevelMap
[
level
]
,
<str>
,
msg
)
;
}
void
serverLog
(
int
level
,
const
char
*
fmt
,
.
.
.
)
{
va_list
ap
;
char
msg
[
LOG_MAX_LEN
]
;
if
(
(
level
&
<hex>
)
<
server
.
verbosity
)
return
;
va_start
(
ap
,
fmt
)
;
vsnprintf
(
msg
,
sizeof
(
msg
)
,
fmt
,
ap
)
;
va_end
(
ap
)
;
serverLogRaw
(
level
,
msg
)
;
}
void
serverLogFromHandler
(
int
level
,
const
char
*
msg
)
{
int
fd
;
int
log_to_stdout
=
server
.
logfile
[
<int>
]
=
=
<str>
;
char
buf
[
<int>
]
;
if
(
(
level
&
<hex>
)
<
server
.
verbosity
|
|
(
log_to_stdout
&
&
server
.
daemonize
)
)
return
;
fd
=
log_to_stdout
?
STDOUT_FILENO
:
open
(
server
.
logfile
,
O_APPEND
|
O_CREAT
|
O_WRONLY
,
<oct>
)
;
if
(
fd
=
=
-
<int>
)
return
;
ll2string
(
buf
,
sizeof
(
buf
)
,
getpid
(
)
)
;
if
(
write
(
fd
,
buf
,
strlen
(
buf
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
ll2string
(
buf
,
sizeof
(
buf
)
,
time
(
NULL
)
)
;
if
(
write
(
fd
,
buf
,
strlen
(
buf
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
msg
,
strlen
(
msg
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
err
:
if
(
!
log_to_stdout
)
close
(
fd
)
;
}
long
long
ustime
(
void
)
{
struct
timeval
tv
;
long
long
ust
;
gettimeofday
(
&
tv
,
NULL
)
;
ust
=
(
(
long
long
)
tv
.
tv_sec
)
*
<int>
;
ust
+
=
tv
.
tv_usec
;
return
ust
;
}
mstime_t
mstime
(
void
)
{
return
ustime
(
)
/
<int>
;
}
void
exitFromChild
(
int
retcode
)
{
exit
(
retcode
)
;
_exit
(
retcode
)
;
}
void
dictVanillaFree
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
zfree
(
val
)
;
}
void
dictListDestructor
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
listRelease
(
(
list
*
)
val
)
;
}
int
dictSdsKeyCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
int
l1
,
l2
;
DICT_NOTUSED
(
privdata
)
;
l1
=
sdslen
(
(
sds
)
key1
)
;
l2
=
sdslen
(
(
sds
)
key2
)
;
if
(
l1
!
=
l2
)
return
<int>
;
return
memcmp
(
key1
,
key2
,
l1
)
=
=
<int>
;
}
int
dictSdsKeyCaseCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
DICT_NOTUSED
(
privdata
)
;
return
strcasecmp
(
key1
,
key2
)
=
=
<int>
;
}
void
dictObjectDestructor
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
if
(
val
=
=
NULL
)
return
;
decrRefCount
(
val
)
;
}
void
dictSdsDestructor
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
sdsfree
(
val
)
;
}
int
dictObjKeyCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
const
robj
*
o1
=
key1
,
*
o2
=
key2
;
return
dictSdsKeyCompare
(
privdata
,
o1
-
>
ptr
,
o2
-
>
ptr
)
;
}
unsigned
int
dictObjHash
(
const
void
*
key
)
{
const
robj
*
o
=
key
;
return
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
}
unsigned
int
dictSdsHash
(
const
void
*
key
)
{
return
dictGenHashFunction
(
(
unsigned
char
*
)
key
,
sdslen
(
(
char
*
)
key
)
)
;
}
unsigned
int
dictSdsCaseHash
(
const
void
*
key
)
{
return
dictGenCaseHashFunction
(
(
unsigned
char
*
)
key
,
sdslen
(
(
char
*
)
key
)
)
;
}
int
dictEncObjKeyCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
robj
*
o1
=
(
robj
*
)
key1
,
*
o2
=
(
robj
*
)
key2
;
int
cmp
;
if
(
o1
-
>
encoding
=
=
OBJ_ENCODING_INT
&
&
o2
-
>
encoding
=
=
OBJ_ENCODING_INT
)
return
o1
-
>
ptr
=
=
o2
-
>
ptr
;
o1
=
getDecodedObject
(
o1
)
;
o2
=
getDecodedObject
(
o2
)
;
cmp
=
dictSdsKeyCompare
(
privdata
,
o1
-
>
ptr
,
o2
-
>
ptr
)
;
decrRefCount
(
o1
)
;
decrRefCount
(
o2
)
;
return
cmp
;
}
unsigned
int
dictEncObjHash
(
const
void
*
key
)
{
robj
*
o
=
(
robj
*
)
key
;
if
(
sdsEncodedObject
(
o
)
)
{
return
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
}
else
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_INT
)
{
char
buf
[
<int>
]
;
int
len
;
len
=
ll2string
(
buf
,
<int>
,
(
long
)
o
-
>
ptr
)
;
return
dictGenHashFunction
(
(
unsigned
char
*
)
buf
,
len
)
;
}
else
{
unsigned
int
hash
;
o
=
getDecodedObject
(
o
)
;
hash
=
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
decrRefCount
(
o
)
;
return
hash
;
}
}
}
dictType
objectKeyPointerValueDictType
=
{
dictEncObjHash
,
NULL
,
NULL
,
dictEncObjKeyCompare
,
dictObjectDestructor
,
NULL
}
;
dictType
setDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
zsetDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
NULL
,
NULL
}
;
dictType
dbDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
dictObjectDestructor
}
;
dictType
shaScriptObjectDictType
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
dictObjectDestructor
}
;
dictType
keyptrDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
NULL
,
NULL
}
;
dictType
commandTableDictType
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
hashDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
dictSdsDestructor
}
;
dictType
keylistDictType
=
{
dictObjHash
,
NULL
,
NULL
,
dictObjKeyCompare
,
dictObjectDestructor
,
dictListDestructor
}
;
dictType
clusterNodesDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
clusterNodesBlackListDictType
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
migrateCacheDictType
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
replScriptCacheDictType
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
int
htNeedsResize
(
dict
*
dict
)
{
long
long
size
,
used
;
size
=
dictSlots
(
dict
)
;
used
=
dictSize
(
dict
)
;
return
(
size
&
&
used
&
&
size
>
DICT_HT_INITIAL_SIZE
&
&
(
used
*
<int>
/
size
<
HASHTABLE_MIN_FILL
)
)
;
}
void
tryResizeHashTables
(
int
dbid
)
{
if
(
htNeedsResize
(
server
.
db
[
dbid
]
.
dict
)
)
dictResize
(
server
.
db
[
dbid
]
.
dict
)
;
if
(
htNeedsResize
(
server
.
db
[
dbid
]
.
expires
)
)
dictResize
(
server
.
db
[
dbid
]
.
expires
)
;
}
int
incrementallyRehash
(
int
dbid
)
{
if
(
dictIsRehashing
(
server
.
db
[
dbid
]
.
dict
)
)
{
dictRehashMilliseconds
(
server
.
db
[
dbid
]
.
dict
,
<int>
)
;
return
<int>
;
}
if
(
dictIsRehashing
(
server
.
db
[
dbid
]
.
expires
)
)
{
dictRehashMilliseconds
(
server
.
db
[
dbid
]
.
expires
,
<int>
)
;
return
<int>
;
}
return
<int>
;
}
void
updateDictResizePolicy
(
void
)
{
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
)
dictEnableResize
(
)
;
else
dictDisableResize
(
)
;
}
int
activeExpireCycleTryExpire
(
redisDb
*
db
,
dictEntry
*
de
,
long
long
now
)
{
long
long
t
=
dictGetSignedIntegerVal
(
de
)
;
if
(
now
>
t
)
{
sds
key
=
dictGetKey
(
de
)
;
robj
*
keyobj
=
createStringObject
(
key
,
sdslen
(
key
)
)
;
propagateExpire
(
db
,
keyobj
,
server
.
lazyfree_lazy_expire
)
;
if
(
server
.
lazyfree_lazy_expire
)
dbAsyncDelete
(
db
,
keyobj
)
;
else
dbSyncDelete
(
db
,
keyobj
)
;
notifyKeyspaceEvent
(
NOTIFY_EXPIRED
,
<str>
,
keyobj
,
db
-
>
id
)
;
decrRefCount
(
keyobj
)
;
server
.
stat_expiredkeys
+
+
;
return
<int>
;
}
else
{
return
<int>
;
}
}
void
activeExpireCycle
(
int
type
)
{
static
unsigned
int
current_db
=
<int>
;
static
int
timelimit_exit
=
<int>
;
static
long
long
last_fast_cycle
=
<int>
;
int
j
,
iteration
=
<int>
;
int
dbs_per_call
=
CRON_DBS_PER_CALL
;
long
long
start
=
ustime
(
)
,
timelimit
;
if
(
type
=
=
ACTIVE_EXPIRE_CYCLE_FAST
)
{
if
(
!
timelimit_exit
)
return
;
if
(
start
<
last_fast_cycle
+
ACTIVE_EXPIRE_CYCLE_FAST_DURATION
*
<int>
)
return
;
last_fast_cycle
=
start
;
}
if
(
dbs_per_call
>
server
.
dbnum
|
|
timelimit_exit
)
dbs_per_call
=
server
.
dbnum
;
timelimit
=
<int>
*
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC
/
server
.
hz
/
<int>
;
timelimit_exit
=
<int>
;
if
(
timelimit
<
=
<int>
)
timelimit
=
<int>
;
if
(
type
=
=
ACTIVE_EXPIRE_CYCLE_FAST
)
timelimit
=
ACTIVE_EXPIRE_CYCLE_FAST_DURATION
;
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
int
expired
;
redisDb
*
db
=
server
.
db
+
(
current_db
%
server
.
dbnum
)
;
current_db
+
+
;
do
{
unsigned
long
num
,
slots
;
long
long
now
,
ttl_sum
;
int
ttl_samples
;
if
(
(
num
=
dictSize
(
db
-
>
expires
)
)
=
=
<int>
)
{
db
-
>
avg_ttl
=
<int>
;
break
;
}
slots
=
dictSlots
(
db
-
>
expires
)
;
now
=
mstime
(
)
;
if
(
num
&
&
slots
>
DICT_HT_INITIAL_SIZE
&
&
(
num
*
<int>
/
slots
<
<int>
)
)
break
;
expired
=
<int>
;
ttl_sum
=
<int>
;
ttl_samples
=
<int>
;
if
(
num
>
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP
)
num
=
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP
;
while
(
num
-
-
)
{
dictEntry
*
de
;
long
long
ttl
;
if
(
(
de
=
dictGetRandomKey
(
db
-
>
expires
)
)
=
=
NULL
)
break
;
ttl
=
dictGetSignedIntegerVal
(
de
)
-
now
;
if
(
activeExpireCycleTryExpire
(
db
,
de
,
now
)
)
expired
+
+
;
if
(
ttl
>
<int>
)
{
ttl_sum
+
=
ttl
;
ttl_samples
+
+
;
}
}
if
(
ttl_samples
)
{
long
long
avg_ttl
=
ttl_sum
/
ttl_samples
;
if
(
db
-
>
avg_ttl
=
=
<int>
)
db
-
>
avg_ttl
=
avg_ttl
;
db
-
>
avg_ttl
=
(
db
-
>
avg_ttl
/
<int>
)
*
<int>
+
(
avg_ttl
/
<int>
)
;
}
iteration
+
+
;
if
(
(
iteration
&
<hex>
)
=
=
<int>
)
{
long
long
elapsed
=
ustime
(
)
-
start
;
latencyAddSampleIfNeeded
(
<str>
,
elapsed
/
<int>
)
;
if
(
elapsed
>
timelimit
)
timelimit_exit
=
<int>
;
}
if
(
timelimit_exit
)
return
;
}
while
(
expired
>
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP
/
<int>
)
;
}
}
unsigned
int
getLRUClock
(
void
)
{
return
(
mstime
(
)
/
LRU_CLOCK_RESOLUTION
)
&
LRU_CLOCK_MAX
;
}
void
trackInstantaneousMetric
(
int
metric
,
long
long
current_reading
)
{
long
long
t
=
mstime
(
)
-
server
.
inst_metric
[
metric
]
.
last_sample_time
;
long
long
ops
=
current_reading
-
server
.
inst_metric
[
metric
]
.
last_sample_count
;
long
long
ops_sec
;
ops_sec
=
t
>
<int>
?
(
ops
*
<int>
/
t
)
:
<int>
;
server
.
inst_metric
[
metric
]
.
samples
[
server
.
inst_metric
[
metric
]
.
idx
]
=
ops_sec
;
server
.
inst_metric
[
metric
]
.
idx
+
+
;
server
.
inst_metric
[
metric
]
.
idx
%
=
STATS_METRIC_SAMPLES
;
server
.
inst_metric
[
metric
]
.
last_sample_time
=
mstime
(
)
;
server
.
inst_metric
[
metric
]
.
last_sample_count
=
current_reading
;
}
long
long
getInstantaneousMetric
(
int
metric
)
{
int
j
;
long
long
sum
=
<int>
;
for
(
j
=
<int>
;
j
<
STATS_METRIC_SAMPLES
;
j
+
+
)
sum
+
=
server
.
inst_metric
[
metric
]
.
samples
[
j
]
;
return
sum
/
STATS_METRIC_SAMPLES
;
}
int
clientsCronHandleTimeout
(
client
*
c
,
mstime_t
now_ms
)
{
time_t
now
=
now_ms
/
<int>
;
if
(
server
.
maxidletime
&
&
!
(
c
-
>
flags
&
CLIENT_SLAVE
)
&
&
!
(
c
-
>
flags
&
CLIENT_MASTER
)
&
&
!
(
c
-
>
flags
&
CLIENT_BLOCKED
)
&
&
!
(
c
-
>
flags
&
CLIENT_PUBSUB
)
&
&
(
now
-
c
-
>
lastinteraction
>
server
.
maxidletime
)
)
{
serverLog
(
LL_VERBOSE
,
<str>
)
;
freeClient
(
c
)
;
return
<int>
;
}
else
if
(
c
-
>
flags
&
CLIENT_BLOCKED
)
{
if
(
c
-
>
bpop
.
timeout
!
=
<int>
&
&
c
-
>
bpop
.
timeout
<
now_ms
)
{
replyToBlockedClientTimedOut
(
c
)
;
unblockClient
(
c
)
;
}
else
if
(
server
.
cluster_enabled
)
{
if
(
clusterRedirectBlockedClientIfNeeded
(
c
)
)
unblockClient
(
c
)
;
}
}
return
<int>
;
}
int
clientsCronResizeQueryBuffer
(
client
*
c
)
{
size_t
querybuf_size
=
sdsAllocSize
(
c
-
>
querybuf
)
;
time_t
idletime
=
server
.
unixtime
-
c
-
>
lastinteraction
;
if
(
(
(
querybuf_size
>
PROTO_MBULK_BIG_ARG
)
&
&
(
querybuf_size
/
(
c
-
>
querybuf_peak
+
<int>
)
)
>
<int>
)
|
|
(
querybuf_size
>
<int>
&
&
idletime
>
<int>
)
)
{
if
(
sdsavail
(
c
-
>
querybuf
)
>
<int>
)
{
c
-
>
querybuf
=
sdsRemoveFreeSpace
(
c
-
>
querybuf
)
;
}
}
c
-
>
querybuf_peak
=
<int>
;
return
<int>
;
}
void
clientsCron
(
void
)
{
int
numclients
=
listLength
(
server
.
clients
)
;
int
iterations
=
numclients
/
server
.
hz
;
mstime_t
now
=
mstime
(
)
;
if
(
iterations
<
CLIENTS_CRON_MIN_ITERATIONS
)
iterations
=
(
numclients
<
CLIENTS_CRON_MIN_ITERATIONS
)
?
numclients
:
CLIENTS_CRON_MIN_ITERATIONS
;
while
(
listLength
(
server
.
clients
)
&
&
iterations
-
-
)
{
client
*
c
;
listNode
*
head
;
listRotate
(
server
.
clients
)
;
head
=
listFirst
(
server
.
clients
)
;
c
=
listNodeValue
(
head
)
;
if
(
clientsCronHandleTimeout
(
c
,
now
)
)
continue
;
if
(
clientsCronResizeQueryBuffer
(
c
)
)
continue
;
}
}
void
databasesCron
(
void
)
{
if
(
server
.
active_expire_enabled
&
&
server
.
masterhost
=
=
NULL
)
activeExpireCycle
(
ACTIVE_EXPIRE_CYCLE_SLOW
)
;
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
)
{
static
unsigned
int
resize_db
=
<int>
;
static
unsigned
int
rehash_db
=
<int>
;
int
dbs_per_call
=
CRON_DBS_PER_CALL
;
int
j
;
if
(
dbs_per_call
>
server
.
dbnum
)
dbs_per_call
=
server
.
dbnum
;
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
tryResizeHashTables
(
resize_db
%
server
.
dbnum
)
;
resize_db
+
+
;
}
if
(
server
.
activerehashing
)
{
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
int
work_done
=
incrementallyRehash
(
rehash_db
%
server
.
dbnum
)
;
rehash_db
+
+
;
if
(
work_done
)
{
break
;
}
}
}
}
}
void
updateCachedTime
(
void
)
{
server
.
unixtime
=
time
(
NULL
)
;
server
.
mstime
=
mstime
(
)
;
}
int
serverCron
(
struct
aeEventLoop
*
eventLoop
,
long
long
id
,
void
*
clientData
)
{
int
j
;
UNUSED
(
eventLoop
)
;
UNUSED
(
id
)
;
UNUSED
(
clientData
)
;
if
(
server
.
watchdog_period
)
watchdogScheduleSignal
(
server
.
watchdog_period
)
;
updateCachedTime
(
)
;
run_with_period
(
<int>
)
{
trackInstantaneousMetric
(
STATS_METRIC_COMMAND
,
server
.
stat_numcommands
)
;
trackInstantaneousMetric
(
STATS_METRIC_NET_INPUT
,
server
.
stat_net_input_bytes
)
;
trackInstantaneousMetric
(
STATS_METRIC_NET_OUTPUT
,
server
.
stat_net_output_bytes
)
;
}
server
.
lruclock
=
getLRUClock
(
)
;
if
(
zmalloc_used_memory
(
)
>
server
.
stat_peak_memory
)
server
.
stat_peak_memory
=
zmalloc_used_memory
(
)
;
server
.
resident_set_size
=
zmalloc_get_rss
(
)
;
if
(
server
.
shutdown_asap
)
{
if
(
prepareForShutdown
(
SHUTDOWN_NOFLAGS
)
=
=
C_OK
)
exit
(
<int>
)
;
serverLog
(
LL_WARNING
,
<str>
)
;
server
.
shutdown_asap
=
<int>
;
}
run_with_period
(
<int>
)
{
for
(
j
=
<int>
;
j
<
server
.
dbnum
;
j
+
+
)
{
long
long
size
,
used
,
vkeys
;
size
=
dictSlots
(
server
.
db
[
j
]
.
dict
)
;
used
=
dictSize
(
server
.
db
[
j
]
.
dict
)
;
vkeys
=
dictSize
(
server
.
db
[
j
]
.
expires
)
;
if
(
used
|
|
vkeys
)
{
serverLog
(
LL_VERBOSE
,
<str>
,
j
,
used
,
vkeys
,
size
)
;
}
}
}
if
(
!
server
.
sentinel_mode
)
{
run_with_period
(
<int>
)
{
serverLog
(
LL_VERBOSE
,
<str>
,
listLength
(
server
.
clients
)
-
listLength
(
server
.
slaves
)
,
listLength
(
server
.
slaves
)
,
zmalloc_used_memory
(
)
)
;
}
}
clientsCron
(
)
;
databasesCron
(
)
;
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
&
&
server
.
aof_rewrite_scheduled
)
{
rewriteAppendOnlyFileBackground
(
)
;
}
if
(
server
.
rdb_child_pid
!
=
-
<int>
|
|
server
.
aof_child_pid
!
=
-
<int>
|
|
ldbPendingChildren
(
)
)
{
int
statloc
;
pid_t
pid
;
if
(
(
pid
=
wait3
(
&
statloc
,
WNOHANG
,
NULL
)
)
!
=
<int>
)
{
int
exitcode
=
WEXITSTATUS
(
statloc
)
;
int
bysignal
=
<int>
;
if
(
WIFSIGNALED
(
statloc
)
)
bysignal
=
WTERMSIG
(
statloc
)
;
if
(
pid
=
=
-
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
<str>
,
strerror
(
errno
)
,
(
int
)
server
.
rdb_child_pid
,
(
int
)
server
.
aof_child_pid
)
;
}
else
if
(
pid
=
=
server
.
rdb_child_pid
)
{
backgroundSaveDoneHandler
(
exitcode
,
bysignal
)
;
}
else
if
(
pid
=
=
server
.
aof_child_pid
)
{
backgroundRewriteDoneHandler
(
exitcode
,
bysignal
)
;
}
else
{
if
(
!
ldbRemoveChild
(
pid
)
)
{
serverLog
(
LL_WARNING
,
<str>
,
(
long
)
pid
)
;
}
}
updateDictResizePolicy
(
)
;
}
}
else
{
for
(
j
=
<int>
;
j
<
server
.
saveparamslen
;
j
+
+
)
{
struct
saveparam
*
sp
=
server
.
saveparams
+
j
;
if
(
server
.
dirty
>
=
sp
-
>
changes
&
&
server
.
unixtime
-
server
.
lastsave
>
sp
-
>
seconds
&
&
(
server
.
unixtime
-
server
.
lastbgsave_try
>
CONFIG_BGSAVE_RETRY_DELAY
|
|
server
.
lastbgsave_status
=
=
C_OK
)
)
{
serverLog
(
LL_NOTICE
,
<str>
,
sp
-
>
changes
,
(
int
)
sp
-
>
seconds
)
;
rdbSaveBackground
(
server
.
rdb_filename
)
;
break
;
}
}
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
&
&
server
.
aof_rewrite_perc
&
&
server
.
aof_current_size
>
server
.
aof_rewrite_min_size
)
{
long
long
base
=
server
.
aof_rewrite_base_size
?
server
.
aof_rewrite_base_size
:
<int>
;
long
long
growth
=
(
server
.
aof_current_size
*
<int>
/
base
)
-
<int>
;
if
(
growth
>
=
server
.
aof_rewrite_perc
)
{
serverLog
(
LL_NOTICE
,
<str>
,
growth
)
;
rewriteAppendOnlyFileBackground
(
)
;
}
}
}
if
(
server
.
aof_flush_postponed_start
)
flushAppendOnlyFile
(
<int>
)
;
run_with_period
(
<int>
)
{
if
(
server
.
aof_last_write_status
=
=
C_ERR
)
flushAppendOnlyFile
(
<int>
)
;
}
freeClientsInAsyncFreeQueue
(
)
;
clientsArePaused
(
)
;
run_with_period
(
<int>
)
replicationCron
(
)
;
run_with_period
(
<int>
)
{
if
(
server
.
cluster_enabled
)
clusterCron
(
)
;
}
run_with_period
(
<int>
)
{
if
(
server
.
sentinel_mode
)
sentinelTimer
(
)
;
}
run_with_period
(
<int>
)
{
migrateCloseTimedoutSockets
(
)
;
}
server
.
cronloops
+
+
;
return
<int>
/
server
.
hz
;
}
void
beforeSleep
(
struct
aeEventLoop
*
eventLoop
)
{
UNUSED
(
eventLoop
)
;
if
(
server
.
cluster_enabled
)
clusterBeforeSleep
(
)
;
if
(
server
.
active_expire_enabled
&
&
server
.
masterhost
=
=
NULL
)
activeExpireCycle
(
ACTIVE_EXPIRE_CYCLE_FAST
)
;
if
(
server
.
get_ack_from_slaves
)
{
robj
*
argv
[
<int>
]
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
replicationFeedSlaves
(
server
.
slaves
,
server
.
slaveseldb
,
argv
,
<int>
)
;
decrRefCount
(
argv
[
<int>
]
)
;
decrRefCount
(
argv
[
<int>
]
)
;
decrRefCount
(
argv
[
<int>
]
)
;
server
.
get_ack_from_slaves
=
<int>
;
}
if
(
listLength
(
server
.
clients_waiting_acks
)
)
processClientsWaitingReplicas
(
)
;
if
(
listLength
(
server
.
unblocked_clients
)
)
processUnblockedClients
(
)
;
flushAppendOnlyFile
(
<int>
)
;
handleClientsWithPendingWrites
(
)
;
}
void
createSharedObjects
(
void
)
{
int
j
;
shared
.
crlf
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
ok
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
err
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
emptybulk
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
czero
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
cone
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
cnegone
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
nullbulk
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
nullmultibulk
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
emptymultibulk
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
pong
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
queued
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
emptyscan
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
wrongtypeerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
nokeyerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
syntaxerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
sameobjecterr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
outofrangeerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
noscripterr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
loadingerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
slowscripterr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
masterdownerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
bgsaveerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
roslaveerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
noautherr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
oomerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
execaborterr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
noreplicaserr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
busykeyerr
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
space
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
colon
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
plus
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
for
(
j
=
<int>
;
j
<
PROTO_SHARED_SELECT_CMDS
;
j
+
+
)
{
char
dictid_str
[
<int>
]
;
int
dictid_len
;
dictid_len
=
ll2string
(
dictid_str
,
sizeof
(
dictid_str
)
,
j
)
;
shared
.
select
[
j
]
=
createObject
(
OBJ_STRING
,
sdscatprintf
(
sdsempty
(
)
,
<str>
,
dictid_len
,
dictid_str
)
)
;
}
shared
.
messagebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
pmessagebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
subscribebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
unsubscribebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
psubscribebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
punsubscribebulk
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
del
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
unlink
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
rpop
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
lpop
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
lpush
=
createStringObject
(
<str>
,
<int>
)
;
for
(
j
=
<int>
;
j
<
OBJ_SHARED_INTEGERS
;
j
+
+
)
{
shared
.
integers
[
j
]
=
makeObjectShared
(
createObject
(
OBJ_STRING
,
(
void
*
)
(
long
)
j
)
)
;
shared
.
integers
[
j
]
-
>
encoding
=
OBJ_ENCODING_INT
;
}
for
(
j
=
<int>
;
j
<
OBJ_SHARED_BULKHDR_LEN
;
j
+
+
)
{
shared
.
mbulkhdr
[
j
]
=
createObject
(
OBJ_STRING
,
sdscatprintf
(
sdsempty
(
)
,
<str>
,
j
)
)
;
shared
.
bulkhdr
[
j
]
=
createObject
(
OBJ_STRING
,
sdscatprintf
(
sdsempty
(
)
,
<str>
,
j
)
)
;
}
shared
.
minstring
=
sdsnew
(
<str>
)
;
shared
.
maxstring
=
sdsnew
(
<str>
)
;
}
void
initServerConfig
(
void
)
{
int
j
;
getRandomHexChars
(
server
.
runid
,
CONFIG_RUN_ID_SIZE
)
;
server
.
configfile
=
NULL
;
server
.
executable
=
NULL
;
server
.
hz
=
CONFIG_DEFAULT_HZ
;
server
.
runid
[
CONFIG_RUN_ID_SIZE
]
=
<str>
;
server
.
arch_bits
=
(
sizeof
(
long
)
=
=
<int>
)
?
<int>
:
<int>
;
server
.
port
=
CONFIG_DEFAULT_SERVER_PORT
;
server
.
tcp_backlog
=
CONFIG_DEFAULT_TCP_BACKLOG
;
server
.
bindaddr_count
=
<int>
;
server
.
unixsocket
=
NULL
;
server
.
unixsocketperm
=
CONFIG_DEFAULT_UNIX_SOCKET_PERM
;
server
.
ipfd_count
=
<int>
;
server
.
sofd
=
-
<int>
;
server
.
protected_mode
=
CONFIG_DEFAULT_PROTECTED_MODE
;
server
.
dbnum
=
CONFIG_DEFAULT_DBNUM
;
server
.
verbosity
=
CONFIG_DEFAULT_VERBOSITY
;
server
.
maxidletime
=
CONFIG_DEFAULT_CLIENT_TIMEOUT
;
server
.
tcpkeepalive
=
CONFIG_DEFAULT_TCP_KEEPALIVE
;
server
.
active_expire_enabled
=
<int>
;
server
.
client_max_querybuf_len
=
PROTO_MAX_QUERYBUF_LEN
;
server
.
saveparams
=
NULL
;
server
.
loading
=
<int>
;
server
.
logfile
=
zstrdup
(
CONFIG_DEFAULT_LOGFILE
)
;
server
.
syslog_enabled
=
CONFIG_DEFAULT_SYSLOG_ENABLED
;
server
.
syslog_ident
=
zstrdup
(
CONFIG_DEFAULT_SYSLOG_IDENT
)
;
server
.
syslog_facility
=
LOG_LOCAL0
;
server
.
daemonize
=
CONFIG_DEFAULT_DAEMONIZE
;
server
.
supervised
=
<int>
;
server
.
supervised_mode
=
SUPERVISED_NONE
;
server
.
aof_state
=
AOF_OFF
;
server
.
aof_fsync
=
CONFIG_DEFAULT_AOF_FSYNC
;
server
.
aof_no_fsync_on_rewrite
=
CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE
;
server
.
aof_rewrite_perc
=
AOF_REWRITE_PERC
;
server
.
aof_rewrite_min_size
=
AOF_REWRITE_MIN_SIZE
;
server
.
aof_rewrite_base_size
=
<int>
;
server
.
aof_rewrite_scheduled
=
<int>
;
server
.
aof_last_fsync
=
time
(
NULL
)
;
server
.
aof_rewrite_time_last
=
-
<int>
;
server
.
aof_rewrite_time_start
=
-
<int>
;
server
.
aof_lastbgrewrite_status
=
C_OK
;
server
.
aof_delayed_fsync
=
<int>
;
server
.
aof_fd
=
-
<int>
;
server
.
aof_selected_db
=
-
<int>
;
server
.
aof_flush_postponed_start
=
<int>
;
server
.
aof_rewrite_incremental_fsync
=
CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC
;
server
.
aof_load_truncated
=
CONFIG_DEFAULT_AOF_LOAD_TRUNCATED
;
server
.
pidfile
=
NULL
;
server
.
rdb_filename
=
zstrdup
(
CONFIG_DEFAULT_RDB_FILENAME
)
;
server
.
aof_filename
=
zstrdup
(
CONFIG_DEFAULT_AOF_FILENAME
)
;
server
.
requirepass
=
NULL
;
server
.
rdb_compression
=
CONFIG_DEFAULT_RDB_COMPRESSION
;
server
.
rdb_checksum
=
CONFIG_DEFAULT_RDB_CHECKSUM
;
server
.
stop_writes_on_bgsave_err
=
CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR
;
server
.
activerehashing
=
CONFIG_DEFAULT_ACTIVE_REHASHING
;
server
.
notify_keyspace_events
=
<int>
;
server
.
maxclients
=
CONFIG_DEFAULT_MAX_CLIENTS
;
server
.
bpop_blocked_clients
=
<int>
;
server
.
maxmemory
=
CONFIG_DEFAULT_MAXMEMORY
;
server
.
maxmemory_policy
=
CONFIG_DEFAULT_MAXMEMORY_POLICY
;
server
.
maxmemory_samples
=
CONFIG_DEFAULT_MAXMEMORY_SAMPLES
;
server
.
hash_max_ziplist_entries
=
OBJ_HASH_MAX_ZIPLIST_ENTRIES
;
server
.
hash_max_ziplist_value
=
OBJ_HASH_MAX_ZIPLIST_VALUE
;
server
.
list_max_ziplist_size
=
OBJ_LIST_MAX_ZIPLIST_SIZE
;
server
.
list_compress_depth
=
OBJ_LIST_COMPRESS_DEPTH
;
server
.
set_max_intset_entries
=
OBJ_SET_MAX_INTSET_ENTRIES
;
server
.
zset_max_ziplist_entries
=
OBJ_ZSET_MAX_ZIPLIST_ENTRIES
;
server
.
zset_max_ziplist_value
=
OBJ_ZSET_MAX_ZIPLIST_VALUE
;
server
.
hll_sparse_max_bytes
=
CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES
;
server
.
shutdown_asap
=
<int>
;
server
.
cluster_enabled
=
<int>
;
server
.
cluster_node_timeout
=
CLUSTER_DEFAULT_NODE_TIMEOUT
;
server
.
cluster_migration_barrier
=
CLUSTER_DEFAULT_MIGRATION_BARRIER
;
server
.
cluster_slave_validity_factor
=
CLUSTER_DEFAULT_SLAVE_VALIDITY
;
server
.
cluster_require_full_coverage
=
CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE
;
server
.
cluster_configfile
=
zstrdup
(
CONFIG_DEFAULT_CLUSTER_CONFIG_FILE
)
;
server
.
cluster_announce_ip
=
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP
;
server
.
cluster_announce_port
=
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT
;
server
.
cluster_announce_bus_port
=
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT
;
server
.
migrate_cached_sockets
=
dictCreate
(
&
migrateCacheDictType
,
NULL
)
;
server
.
next_client_id
=
<int>
;
server
.
loading_process_events_interval_bytes
=
(
<int>
*
<int>
*
<int>
)
;
server
.
lazyfree_lazy_eviction
=
CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION
;
server
.
lazyfree_lazy_expire
=
CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE
;
server
.
lazyfree_lazy_server_del
=
CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL
;
server
.
lruclock
=
getLRUClock
(
)
;
resetServerSaveParams
(
)
;
appendServerSaveParams
(
<int>
*
<int>
,
<int>
)
;
appendServerSaveParams
(
<int>
,
<int>
)
;
appendServerSaveParams
(
<int>
,
<int>
)
;
server
.
masterauth
=
NULL
;
server
.
masterhost
=
NULL
;
server
.
masterport
=
<int>
;
server
.
master
=
NULL
;
server
.
cached_master
=
NULL
;
server
.
repl_master_initial_offset
=
-
<int>
;
server
.
repl_state
=
REPL_STATE_NONE
;
server
.
repl_syncio_timeout
=
CONFIG_REPL_SYNCIO_TIMEOUT
;
server
.
repl_serve_stale_data
=
CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA
;
server
.
repl_slave_ro
=
CONFIG_DEFAULT_SLAVE_READ_ONLY
;
server
.
repl_slave_lazy_flush
=
CONFIG_DEFAULT_SLAVE_LAZY_FLUSH
;
server
.
repl_down_since
=
<int>
;
server
.
repl_disable_tcp_nodelay
=
CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY
;
server
.
repl_diskless_sync
=
CONFIG_DEFAULT_REPL_DISKLESS_SYNC
;
server
.
repl_diskless_sync_delay
=
CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY
;
server
.
repl_ping_slave_period
=
CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD
;
server
.
repl_timeout
=
CONFIG_DEFAULT_REPL_TIMEOUT
;
server
.
repl_min_slaves_to_write
=
CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE
;
server
.
repl_min_slaves_max_lag
=
CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG
;
server
.
slave_priority
=
CONFIG_DEFAULT_SLAVE_PRIORITY
;
server
.
master_repl_offset
=
<int>
;
server
.
repl_backlog
=
NULL
;
server
.
repl_backlog_size
=
CONFIG_DEFAULT_REPL_BACKLOG_SIZE
;
server
.
repl_backlog_histlen
=
<int>
;
server
.
repl_backlog_idx
=
<int>
;
server
.
repl_backlog_off
=
<int>
;
server
.
repl_backlog_time_limit
=
CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT
;
server
.
repl_no_slaves_since
=
time
(
NULL
)
;
for
(
j
=
<int>
;
j
<
CLIENT_TYPE_OBUF_COUNT
;
j
+
+
)
server
.
client_obuf_limits
[
j
]
=
clientBufferLimitsDefaults
[
j
]
;
R_Zero
=
<float>
;
R_PosInf
=
<float>
/
R_Zero
;
R_NegInf
=
-
<float>
/
R_Zero
;
R_Nan
=
R_Zero
/
R_Zero
;
<UNK>
<UNK>
<EOF>
<START>
unsigned
int
lzf_compress
(
const
void
*
const
in_data
,
unsigned
int
in_len
,
void
*
out_data
,
unsigned
int
out_len
,
LZF_STATE
htab
)
{
LZF_STATE
htab
;
const
u8
*
ip
=
(
const
u8
*
)
in_data
;
u8
*
op
=
(
u8
*
)
out_data
;
const
u8
*
in_end
=
ip
+
in_len
;
u8
*
out_end
=
op
+
out_len
;
const
u8
*
ref
;
unsigned
_int64
off
;
unsigned
long
off
;
unsigned
int
hval
;
int
lit
;
if
(
!
in_len
|
|
!
out_len
)
return
<int>
;
memset
(
htab
,
<int>
,
sizeof
(
htab
)
)
;
lit
=
<int>
;
op
+
+
;
hval
=
FRST
(
ip
)
;
while
(
ip
<
in_end
-
<int>
)
{
LZF_HSLOT
*
hslot
;
hval
=
NEXT
(
hval
,
ip
)
;
hslot
=
htab
+
IDX
(
hval
)
;
ref
=
*
hslot
+
LZF_HSLOT_BIAS
;
*
hslot
=
ip
-
LZF_HSLOT_BIAS
;
if
(
<int>
&
&
ref
<
ip
&
&
(
off
=
ip
-
ref
-
<int>
)
<
MAX_OFF
&
&
ref
>
(
u8
*
)
in_data
&
&
ref
[
<int>
]
=
=
ip
[
<int>
]
&
&
(
(
ref
[
<int>
]
<
<
<int>
)
|
ref
[
<int>
]
)
=
=
(
(
ip
[
<int>
]
<
<
<int>
)
|
ip
[
<int>
]
)
&
&
*
(
u16
*
)
ref
=
=
*
(
u16
*
)
ip
)
{
unsigned
int
len
=
<int>
;
unsigned
int
maxlen
=
in_end
-
ip
-
len
;
maxlen
=
maxlen
>
MAX_REF
?
MAX_REF
:
maxlen
;
if
(
expect_false
(
op
+
<int>
+
<int>
>
=
out_end
)
)
if
(
op
-
!
lit
+
<int>
+
<int>
>
=
out_end
)
return
<int>
;
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
op
-
=
!
lit
;
for
(
;
;
)
{
if
(
expect_true
(
maxlen
>
<int>
)
)
{
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
}
do
len
+
+
;
while
(
len
<
maxlen
&
&
ref
[
len
]
=
=
ip
[
len
]
)
;
break
;
}
len
-
=
<int>
;
ip
+
+
;
if
(
len
<
<int>
)
{
*
op
+
+
=
(
off
>
>
<int>
)
+
(
len
<
<
<int>
)
;
}
else
{
*
op
+
+
=
(
off
>
>
<int>
)
+
(
<int>
<
<
<int>
)
;
*
op
+
+
=
len
-
<int>
;
}
*
op
+
+
=
off
;
lit
=
<int>
;
op
+
+
;
ip
+
=
len
+
<int>
;
if
(
expect_false
(
ip
>
=
in_end
-
<int>
)
)
break
;
-
-
ip
;
-
-
ip
;
hval
=
FRST
(
ip
)
;
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
ip
-
=
len
+
<int>
;
do
{
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
}
while
(
len
-
-
)
;
}
else
{
if
(
expect_false
(
op
>
=
out_end
)
)
return
<int>
;
lit
+
+
;
*
op
+
+
=
*
ip
+
+
;
if
(
expect_false
(
lit
=
=
MAX_LIT
)
)
{
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
lit
=
<int>
;
op
+
+
;
}
}
}
if
(
op
+
<int>
>
out_end
)
return
<int>
;
while
(
ip
<
in_end
)
{
lit
+
+
;
*
op
+
+
=
*
ip
+
+
;
if
(
expect_false
(
lit
=
=
MAX_LIT
)
)
{
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
lit
=
<int>
;
op
+
+
;
}
}
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
op
-
=
!
lit
;
return
op
-
(
u8
*
)
out_data
;
}
<UNK>
<UNK>
<EOF>
<START>
static
pthread_t
bio_threads
[
BIO_NUM_OPS
]
;
static
pthread_mutex_t
bio_mutex
[
BIO_NUM_OPS
]
;
static
pthread_cond_t
bio_newjob_cond
[
BIO_NUM_OPS
]
;
static
pthread_cond_t
bio_step_cond
[
BIO_NUM_OPS
]
;
static
list
*
bio_jobs
[
BIO_NUM_OPS
]
;
static
unsigned
long
long
bio_pending
[
BIO_NUM_OPS
]
;
struct
bio_job
{
time_t
time
;
void
*
arg1
,
*
arg2
,
*
arg3
;
}
;
void
*
bioProcessBackgroundJobs
(
void
*
arg
)
;
void
lazyfreeFreeObjectFromBioThread
(
robj
*
o
)
;
void
lazyfreeFreeDatabaseFromBioThread
(
dict
*
ht1
,
dict
*
ht2
)
;
void
lazyfreeFreeSlotsMapFromBioThread
(
zskiplist
*
sl
)
;
void
bioInit
(
void
)
{
pthread_attr_t
attr
;
pthread_t
thread
;
size_t
stacksize
;
int
j
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
pthread_mutex_init
(
&
bio_mutex
[
j
]
,
NULL
)
;
pthread_cond_init
(
&
bio_newjob_cond
[
j
]
,
NULL
)
;
pthread_cond_init
(
&
bio_step_cond
[
j
]
,
NULL
)
;
bio_jobs
[
j
]
=
listCreate
(
)
;
bio_pending
[
j
]
=
<int>
;
}
pthread_attr_init
(
&
attr
)
;
pthread_attr_getstacksize
(
&
attr
,
&
stacksize
)
;
if
(
!
stacksize
)
stacksize
=
<int>
;
while
(
stacksize
<
REDIS_THREAD_STACK_SIZE
)
stacksize
*
=
<int>
;
pthread_attr_setstacksize
(
&
attr
,
stacksize
)
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
void
*
arg
=
(
void
*
)
(
unsigned
long
)
j
;
if
(
pthread_create
(
&
thread
,
&
attr
,
bioProcessBackgroundJobs
,
arg
)
!
=
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
)
;
exit
(
<int>
)
;
}
bio_threads
[
j
]
=
thread
;
}
}
void
bioCreateBackgroundJob
(
int
type
,
void
*
arg1
,
void
*
arg2
,
void
*
arg3
)
{
struct
bio_job
*
job
=
zmalloc
(
sizeof
(
*
job
)
)
;
job
-
>
time
=
time
(
NULL
)
;
job
-
>
arg1
=
arg1
;
job
-
>
arg2
=
arg2
;
job
-
>
arg3
=
arg3
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
listAddNodeTail
(
bio_jobs
[
type
]
,
job
)
;
bio_pending
[
type
]
+
+
;
pthread_cond_signal
(
&
bio_newjob_cond
[
type
]
)
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
}
void
*
bioProcessBackgroundJobs
(
void
*
arg
)
{
struct
bio_job
*
job
;
unsigned
long
type
=
(
unsigned
long
)
arg
;
sigset_t
sigset
;
if
(
type
>
=
BIO_NUM_OPS
)
{
serverLog
(
LL_WARNING
,
<str>
,
type
)
;
return
NULL
;
}
pthread_setcancelstate
(
PTHREAD_CANCEL_ENABLE
,
NULL
)
;
pthread_setcanceltype
(
PTHREAD_CANCEL_ASYNCHRONOUS
,
NULL
)
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
sigemptyset
(
&
sigset
)
;
sigaddset
(
&
sigset
,
SIGALRM
)
;
if
(
pthread_sigmask
(
SIG_BLOCK
,
&
sigset
,
NULL
)
)
serverLog
(
LL_WARNING
,
<str>
,
strerror
(
errno
)
)
;
while
(
<int>
)
{
listNode
*
ln
;
if
(
listLength
(
bio_jobs
[
type
]
)
=
=
<int>
)
{
pthread_cond_wait
(
&
bio_newjob_cond
[
type
]
,
&
bio_mutex
[
type
]
)
;
continue
;
}
ln
=
listFirst
(
bio_jobs
[
type
]
)
;
job
=
ln
-
>
value
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
if
(
type
=
=
BIO_CLOSE_FILE
)
{
close
(
(
long
)
job
-
>
arg1
)
;
}
else
if
(
type
=
=
BIO_AOF_FSYNC
)
{
aof_fsync
(
(
long
)
job
-
>
arg1
)
;
}
else
if
(
type
=
=
BIO_LAZY_FREE
)
{
if
(
job
-
>
arg1
)
lazyfreeFreeObjectFromBioThread
(
job
-
>
arg1
)
;
else
if
(
job
-
>
arg2
&
&
job
-
>
arg3
)
lazyfreeFreeDatabaseFromBioThread
(
job
-
>
arg2
,
job
-
>
arg3
)
;
else
if
(
job
-
>
arg3
)
lazyfreeFreeSlotsMapFromBioThread
(
job
-
>
arg3
)
;
}
else
{
serverPanic
(
<str>
)
;
}
zfree
(
job
)
;
pthread_cond_broadcast
(
&
bio_step_cond
[
type
]
)
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
listDelNode
(
bio_jobs
[
type
]
,
ln
)
;
bio_pending
[
type
]
-
-
;
}
}
unsigned
long
long
bioPendingJobsOfType
(
int
type
)
{
unsigned
long
long
val
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
return
val
;
}
unsigned
long
long
bioWaitStepOfType
(
int
type
)
{
unsigned
long
long
val
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
if
(
val
!
=
<int>
)
{
pthread_cond_wait
(
&
bio_step_cond
[
type
]
,
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
}
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
return
val
;
}
void
bioKillThreads
(
void
)
{
int
err
,
j
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
if
(
pthread_cancel
(
bio_threads
[
j
]
)
=
=
<int>
)
{
if
(
(
err
=
pthread_join
(
bio_threads
[
j
]
,
NULL
)
)
!
=
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
,
j
,
strerror
(
err
)
)
;
}
else
{
serverLog
(
LL_WARNING
,
<str>
,
j
)
;
}
}
}
}
<UNK>
<UNK>
<EOF>
<START>
static
char
error
[
<int>
]
;
static
off_t
epos
;
int
consumeNewline
(
char
*
buf
)
{
if
(
strncmp
(
buf
,
<str>
,
<int>
)
!
=
<int>
)
{
ERROR
(
<str>
,
buf
[
<int>
]
,
buf
[
<int>
]
)
;
return
<int>
;
}
return
<int>
;
}
int
readLong
(
FILE
*
fp
,
char
prefix
,
long
*
target
)
{
char
buf
[
<int>
]
,
*
eptr
;
epos
=
ftello
(
fp
)
;
if
(
fgets
(
buf
,
sizeof
(
buf
)
,
fp
)
=
=
NULL
)
{
return
<int>
;
}
if
(
buf
[
<int>
]
!
=
prefix
)
{
ERROR
(
<str>
,
buf
[
<int>
]
,
prefix
)
;
return
<int>
;
}
*
target
=
strtol
(
buf
+
<int>
,
&
eptr
,
<int>
)
;
return
consumeNewline
(
eptr
)
;
}
int
readBytes
(
FILE
*
fp
,
char
*
target
,
long
length
)
{
long
real
;
epos
=
ftello
(
fp
)
;
real
=
fread
(
target
,
<int>
,
length
,
fp
)
;
if
(
real
!
=
length
)
{
ERROR
(
<str>
,
length
,
real
)
;
return
<int>
;
}
return
<int>
;
}
int
readString
(
FILE
*
fp
,
char
*
*
target
)
{
long
len
;
*
target
=
NULL
;
if
(
!
readLong
(
fp
,
<str>
,
&
len
)
)
{
return
<int>
;
}
len
+
=
<int>
;
*
target
=
(
char
*
)
malloc
(
len
)
;
if
(
!
readBytes
(
fp
,
*
target
,
len
)
)
{
return
<int>
;
}
if
(
!
consumeNewline
(
*
target
+
len
-
<int>
)
)
{
return
<int>
;
}
(
*
target
)
[
len
-
<int>
]
=
<str>
;
return
<int>
;
}
int
readArgc
(
FILE
*
fp
,
long
*
target
)
{
return
readLong
(
fp
,
<str>
,
target
)
;
}
off_t
process
(
FILE
*
fp
)
{
long
argc
;
off_t
pos
=
<int>
;
int
i
,
multi
=
<int>
;
char
*
str
;
while
(
<int>
)
{
if
(
!
multi
)
pos
=
ftello
(
fp
)
;
if
(
!
readArgc
(
fp
,
&
argc
)
)
break
;
for
(
i
=
<int>
;
i
<
argc
;
i
+
+
)
{
if
(
!
readString
(
fp
,
&
str
)
)
break
;
if
(
i
=
=
<int>
)
{
if
(
strcasecmp
(
str
,
<str>
)
=
=
<int>
)
{
if
(
multi
+
+
)
{
ERROR
(
<str>
)
;
break
;
}
}
else
if
(
strcasecmp
(
str
,
<str>
)
=
=
<int>
)
{
if
(
-
-
multi
)
{
ERROR
(
<str>
)
;
break
;
}
}
}
free
(
str
)
;
}
if
(
i
<
argc
)
{
if
(
str
)
free
(
str
)
;
break
;
}
}
if
(
feof
(
fp
)
&
&
multi
&
&
strlen
(
error
)
=
=
<int>
)
{
ERROR
(
<str>
)
;
}
if
(
strlen
(
error
)
>
<int>
)
{
printf
(
<str>
,
error
)
;
}
return
pos
;
}
int
main
(
int
argc
,
char
*
*
argv
)
{
char
*
filename
;
int
fix
=
<int>
;
if
(
argc
<
<int>
)
{
printf
(
<str>
,
argv
[
<int>
]
)
;
exit
(
<int>
)
;
}
else
if
(
argc
=
=
<int>
)
{
filename
=
argv
[
<int>
]
;
}
else
if
(
argc
=
=
<int>
)
{
if
(
strcmp
(
argv
[
<int>
]
,
<str>
)
!
=
<int>
)
{
printf
(
<str>
,
argv
[
<int>
]
)
;
exit
(
<int>
)
;
}
filename
=
argv
[
<int>
]
;
fix
=
<int>
;
}
else
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
FILE
*
fp
=
fopen
(
filename
,
<str>
)
;
if
(
fp
=
=
NULL
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
struct
redis_stat
sb
;
if
(
redis_fstat
(
fileno
(
fp
)
,
&
sb
)
=
=
-
<int>
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
off_t
size
=
sb
.
st_size
;
if
(
size
=
=
<int>
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
off_t
pos
=
process
(
fp
)
;
off_t
diff
=
size
-
pos
;
printf
(
<str>
,
(
long
long
)
size
,
(
long
long
)
pos
,
(
long
long
)
diff
)
;
if
(
diff
>
<int>
)
{
if
(
fix
)
{
char
buf
[
<int>
]
;
printf
(
<str>
,
(
long
long
)
size
,
(
long
long
)
diff
,
(
long
long
)
pos
)
;
printf
(
<str>
)
;
if
(
fgets
(
buf
,
sizeof
(
buf
)
,
stdin
)
=
=
NULL
|
|
strncasecmp
(
buf
,
<str>
,
<int>
)
!
=
<int>
)
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
if
(
ftruncate
(
fileno
(
fp
)
,
pos
)
=
=
-
<int>
)
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
else
{
printf
(
<str>
)
;
}
}
else
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
}
else
{
printf
(
<str>
)
;
}
fclose
(
fp
)
;
return
<int>
;
}
<UNK>
<UNK>
<EOF>
<START>
void
hashTypeTryConversion
(
robj
*
o
,
robj
*
*
argv
,
int
start
,
int
end
)
{
int
i
;
if
(
o
-
>
encoding
!
=
OBJ_ENCODING_ZIPLIST
)
return
;
for
(
i
=
start
;
i
<
=
end
;
i
+
+
)
{
if
(
sdsEncodedObject
(
argv
[
i
]
)
&
&
sdslen
(
argv
[
i
]
-
>
ptr
)
>
server
.
hash_max_ziplist_value
)
{
hashTypeConvert
(
o
,
OBJ_ENCODING_HT
)
;
break
;
}
}
}
int
hashTypeGetFromZiplist
(
robj
*
o
,
sds
field
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
unsigned
char
*
zl
,
*
fptr
=
NULL
,
*
vptr
=
NULL
;
int
ret
;
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
ZIPLIST_HEAD
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
ziplistFind
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
}
}
if
(
vptr
!
=
NULL
)
{
ret
=
ziplistGet
(
vptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
return
<int>
;
}
return
-
<int>
;
}
sds
hashTypeGetFromHashTable
(
robj
*
o
,
sds
field
)
{
dictEntry
*
de
;
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
;
de
=
dictFind
(
o
-
>
ptr
,
field
)
;
if
(
de
=
=
NULL
)
return
NULL
;
return
dictGetVal
(
de
)
;
}
int
hashTypeGetValue
(
robj
*
o
,
sds
field
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
*
vstr
=
NULL
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
vstr
,
vlen
,
vll
)
=
=
<int>
)
return
C_OK
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
;
if
(
(
value
=
hashTypeGetFromHashTable
(
o
,
field
)
)
!
=
NULL
)
{
*
vstr
=
(
unsigned
char
*
)
value
;
*
vlen
=
sdslen
(
value
)
;
return
C_OK
;
}
}
else
{
serverPanic
(
<str>
)
;
}
return
C_ERR
;
}
robj
*
hashTypeGetValueObject
(
robj
*
o
,
sds
field
)
{
unsigned
char
*
vstr
;
unsigned
int
vlen
;
long
long
vll
;
if
(
hashTypeGetValue
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
C_ERR
)
return
NULL
;
if
(
vstr
)
return
createStringObject
(
(
char
*
)
vstr
,
vlen
)
;
else
return
createStringObjectFromLongLong
(
vll
)
;
}
size_t
hashTypeGetValueLength
(
robj
*
o
,
sds
field
)
{
size_t
len
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
<int>
)
len
=
vstr
?
vlen
:
sdigits10
(
vll
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
aux
;
if
(
(
aux
=
hashTypeGetFromHashTable
(
o
,
field
)
)
!
=
NULL
)
len
=
sdslen
(
aux
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
len
;
}
int
hashTypeExists
(
robj
*
o
,
sds
field
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
<int>
)
return
<int>
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
hashTypeGetFromHashTable
(
o
,
field
)
!
=
NULL
)
return
<int>
;
}
else
{
serverPanic
(
<str>
)
;
}
return
<int>
;
}
int
hashTypeSet
(
robj
*
o
,
sds
field
,
sds
value
,
int
flags
)
{
int
update
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
,
*
fptr
,
*
vptr
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
ZIPLIST_HEAD
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
ziplistFind
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
update
=
<int>
;
zl
=
ziplistDelete
(
zl
,
&
vptr
)
;
zl
=
ziplistInsert
(
zl
,
vptr
,
(
unsigned
char
*
)
value
,
sdslen
(
value
)
)
;
}
}
if
(
!
update
)
{
zl
=
ziplistPush
(
zl
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
ZIPLIST_TAIL
)
;
zl
=
ziplistPush
(
zl
,
(
unsigned
char
*
)
value
,
sdslen
(
value
)
,
ZIPLIST_TAIL
)
;
}
o
-
>
ptr
=
zl
;
if
(
hashTypeLength
(
o
)
>
server
.
hash_max_ziplist_entries
)
hashTypeConvert
(
o
,
OBJ_ENCODING_HT
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
dictEntry
*
de
=
dictFind
(
o
-
>
ptr
,
field
)
;
if
(
de
)
{
sdsfree
(
dictGetVal
(
de
)
)
;
if
(
flags
&
HASH_SET_TAKE_VALUE
)
{
dictGetVal
(
de
)
=
value
;
value
=
NULL
;
}
else
{
dictGetVal
(
de
)
=
sdsdup
(
value
)
;
}
update
=
<int>
;
}
else
{
sds
f
,
v
;
if
(
flags
&
HASH_SET_TAKE_FIELD
)
{
f
=
field
;
field
=
NULL
;
}
else
{
f
=
sdsdup
(
field
)
;
}
if
(
flags
&
HASH_SET_TAKE_VALUE
)
{
v
=
value
;
value
=
NULL
;
}
else
{
v
=
sdsdup
(
value
)
;
}
dictAdd
(
o
-
>
ptr
,
f
,
v
)
;
}
}
else
{
serverPanic
(
<str>
)
;
}
if
(
flags
&
HASH_SET_TAKE_FIELD
&
&
field
)
sdsfree
(
field
)
;
if
(
flags
&
HASH_SET_TAKE_VALUE
&
&
value
)
sdsfree
(
value
)
;
return
update
;
}
int
hashTypeDelete
(
robj
*
o
,
sds
field
)
{
int
deleted
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
,
*
fptr
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
ZIPLIST_HEAD
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
ziplistFind
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
zl
=
ziplistDelete
(
zl
,
&
fptr
)
;
zl
=
ziplistDelete
(
zl
,
&
fptr
)
;
o
-
>
ptr
=
zl
;
deleted
=
<int>
;
}
}
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
dictDelete
(
(
dict
*
)
o
-
>
ptr
,
field
)
=
=
C_OK
)
{
deleted
=
<int>
;
if
(
htNeedsResize
(
o
-
>
ptr
)
)
dictResize
(
o
-
>
ptr
)
;
}
}
else
{
serverPanic
(
<str>
)
;
}
return
deleted
;
}
unsigned
long
hashTypeLength
(
robj
*
o
)
{
unsigned
long
length
=
ULONG_MAX
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
length
=
ziplistLen
(
o
-
>
ptr
)
/
<int>
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
length
=
dictSize
(
(
dict
*
)
o
-
>
ptr
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
length
;
}
hashTypeIterator
*
hashTypeInitIterator
(
robj
*
subject
)
{
hashTypeIterator
*
hi
=
zmalloc
(
sizeof
(
hashTypeIterator
)
)
;
hi
-
>
subject
=
subject
;
hi
-
>
encoding
=
subject
-
>
encoding
;
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
hi
-
>
fptr
=
NULL
;
hi
-
>
vptr
=
NULL
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
hi
-
>
di
=
dictGetIterator
(
subject
-
>
ptr
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
hi
;
}
void
hashTypeReleaseIterator
(
hashTypeIterator
*
hi
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
dictReleaseIterator
(
hi
-
>
di
)
;
zfree
(
hi
)
;
}
int
hashTypeNext
(
hashTypeIterator
*
hi
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
;
unsigned
char
*
fptr
,
*
vptr
;
zl
=
hi
-
>
subject
-
>
ptr
;
fptr
=
hi
-
>
fptr
;
vptr
=
hi
-
>
vptr
;
if
(
fptr
=
=
NULL
)
{
serverAssert
(
vptr
=
=
NULL
)
;
fptr
=
ziplistIndex
(
zl
,
<int>
)
;
}
else
{
serverAssert
(
vptr
!
=
NULL
)
;
fptr
=
ziplistNext
(
zl
,
vptr
)
;
}
if
(
fptr
=
=
NULL
)
return
C_ERR
;
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
hi
-
>
fptr
=
fptr
;
hi
-
>
vptr
=
vptr
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
(
hi
-
>
de
=
dictNext
(
hi
-
>
di
)
)
=
=
NULL
)
return
C_ERR
;
}
else
{
serverPanic
(
<str>
)
;
}
return
C_OK
;
}
void
hashTypeCurrentFromZiplist
(
hashTypeIterator
*
hi
,
int
what
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
int
ret
;
serverAssert
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
if
(
what
&
OBJ_HASH_KEY
)
{
ret
=
ziplistGet
(
hi
-
>
fptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
}
else
{
ret
=
ziplistGet
(
hi
-
>
vptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
}
}
sds
hashTypeCurrentFromHashTable
(
hashTypeIterator
*
hi
,
int
what
)
{
serverAssert
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
;
if
(
what
&
OBJ_HASH_KEY
)
{
return
dictGetKey
(
hi
-
>
de
)
;
}
else
{
return
dictGetVal
(
hi
-
>
de
)
;
}
}
void
hashTypeCurrentObject
(
hashTypeIterator
*
hi
,
int
what
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
*
vstr
=
NULL
;
hashTypeCurrentFromZiplist
(
hi
,
what
,
vstr
,
vlen
,
vll
)
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
ele
=
hashTypeCurrentFromHashTable
(
hi
,
what
)
;
*
vstr
=
(
unsigned
char
*
)
ele
;
*
vlen
=
sdslen
(
ele
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
sds
hashTypeCurrentObjectNewSds
(
hashTypeIterator
*
hi
,
int
what
)
{
unsigned
char
*
vstr
;
unsigned
int
vlen
;
long
long
vll
;
hashTypeCurrentObject
(
hi
,
what
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
vstr
)
return
sdsnewlen
(
vstr
,
vlen
)
;
return
sdsfromlonglong
(
vll
)
;
}
robj
*
hashTypeLookupWriteOrCreate
(
client
*
c
,
robj
*
key
)
{
robj
*
o
=
lookupKeyWrite
(
c
-
>
db
,
key
)
;
if
(
o
=
=
NULL
)
{
o
=
createHashObject
(
)
;
dbAdd
(
c
-
>
db
,
key
,
o
)
;
}
else
{
if
(
o
-
>
type
!
=
OBJ_HASH
)
{
addReply
(
c
,
shared
.
wrongtypeerr
)
;
return
NULL
;
}
}
return
o
;
}
void
hashTypeConvertZiplist
(
robj
*
o
,
int
enc
)
{
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
if
(
enc
=
=
OBJ_ENCODING_ZIPLIST
)
{
}
else
if
(
enc
=
=
OBJ_ENCODING_HT
)
{
hashTypeIterator
*
hi
;
dict
*
dict
;
int
ret
;
hi
=
hashTypeInitIterator
(
o
)
;
dict
=
dictCreate
(
&
hashDictType
,
NULL
)
;
while
(
hashTypeNext
(
hi
)
!
=
C_ERR
)
{
sds
key
,
value
;
key
=
hashTypeCurrentObjectNewSds
(
hi
,
OBJ_HASH_KEY
)
;
value
=
hashTypeCurrentObjectNewSds
(
hi
,
OBJ_HASH_VALUE
)
;
ret
=
dictAdd
(
dict
,
key
,
value
)
;
if
(
ret
!
=
DICT_OK
)
{
serverLogHexDump
(
LL_WARNING
,
<str>
,
o
-
>
ptr
,
ziplistBlobLen
(
o
-
>
ptr
)
)
;
serverPanic
(
<str>
)
;
}
}
hashTypeReleaseIterator
(
hi
)
;
zfree
(
o
-
>
ptr
)
;
o
-
>
encoding
=
OBJ_ENCODING_HT
;
o
-
>
ptr
=
dict
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
hashTypeConvert
(
robj
*
o
,
int
enc
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
hashTypeConvertZiplist
(
o
,
enc
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
serverPanic
(
<str>
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
hsetCommand
(
client
*
c
)
{
int
update
;
robj
*
o
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
<int>
)
;
update
=
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
HASH_SET_COPY
)
;
addReply
(
c
,
update
?
shared
.
czero
:
shared
.
cone
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
hsetnxCommand
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
<int>
)
;
if
(
hashTypeExists
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
)
{
addReply
(
c
,
shared
.
czero
)
;
}
else
{
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
HASH_SET_COPY
)
;
addReply
(
c
,
shared
.
cone
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
}
void
hmsetCommand
(
client
*
c
)
{
int
i
;
robj
*
o
;
if
(
(
c
-
>
argc
%
<int>
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
c
-
>
argc
-
<int>
)
;
for
(
i
=
<int>
;
i
<
c
-
>
argc
;
i
+
=
<int>
)
{
hashTypeSet
(
o
,
c
-
>
argv
[
i
]
-
>
ptr
,
c
-
>
argv
[
i
+
<int>
]
-
>
ptr
,
HASH_SET_COPY
)
;
}
addReply
(
c
,
shared
.
ok
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
hincrbyCommand
(
client
*
c
)
{
long
long
value
,
incr
,
oldvalue
;
robj
*
o
;
sds
new
;
unsigned
char
*
vstr
;
unsigned
int
vlen
;
if
(
getLongLongFromObjectOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
&
incr
,
NULL
)
!
=
C_OK
)
return
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
if
(
hashTypeGetValue
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
&
vstr
,
&
vlen
,
&
value
)
=
=
C_OK
)
{
if
(
vstr
)
{
if
(
string2ll
(
(
char
*
)
vstr
,
vlen
,
&
value
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
}
}
else
{
value
=
<int>
;
}
oldvalue
=
value
;
if
(
(
incr
<
<int>
&
&
oldvalue
<
<int>
&
&
incr
<
(
LLONG_MIN
-
oldvalue
)
)
|
|
(
incr
>
<int>
&
&
oldvalue
>
<int>
&
&
incr
>
(
LLONG_MAX
-
oldvalue
)
)
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
value
+
=
incr
;
new
=
sdsfromlonglong
(
value
)
;
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
new
,
HASH_SET_TAKE_VALUE
)
;
addReplyLongLong
(
c
,
value
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
hincrbyfloatCommand
(
client
*
c
)
{
long
double
value
,
incr
;
long
long
ll
;
robj
*
o
;
sds
new
;
unsigned
char
*
vstr
;
unsigned
int
vlen
;
if
(
getLongDoubleFromObjectOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
&
incr
,
NULL
)
!
=
C_OK
)
return
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
if
(
hashTypeGetValue
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
&
vstr
,
&
vlen
,
&
ll
)
=
=
C_OK
)
{
if
(
vstr
)
{
if
(
string2ld
(
(
char
*
)
vstr
,
vlen
,
&
value
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
}
else
{
value
=
(
long
double
)
ll
;
}
}
else
{
value
=
<int>
;
}
value
+
=
incr
;
char
buf
[
<int>
]
;
int
len
=
ld2string
(
buf
,
sizeof
(
buf
)
,
value
,
<int>
)
;
new
=
sdsnewlen
(
buf
,
len
)
;
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
new
,
HASH_SET_TAKE_VALUE
)
;
addReplyBulkCBuffer
(
c
,
buf
,
len
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
robj
*
aux
,
*
newobj
;
aux
=
createStringObject
(
<str>
,
<int>
)
;
newobj
=
createRawStringObject
(
buf
,
len
)
;
rewriteClientCommandArgument
(
c
,
<int>
,
aux
)
;
decrRefCount
(
aux
)
;
rewriteClientCommandArgument
(
c
,
<int>
,
newobj
)
;
decrRefCount
(
newobj
)
;
}
static
void
addHashFieldToReply
(
client
*
c
,
robj
*
o
,
sds
field
)
{
int
ret
;
if
(
o
=
=
NULL
)
{
addReply
(
c
,
shared
.
nullbulk
)
;
return
;
}
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
ret
=
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
ret
<
<int>
)
{
addReply
(
c
,
shared
.
nullbulk
)
;
}
else
{
if
(
vstr
)
{
addReplyBulkCBuffer
(
c
,
vstr
,
vlen
)
;
}
else
{
addReplyBulkLongLong
(
c
,
vll
)
;
}
}
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
=
hashTypeGetFromHashTable
(
o
,
field
)
;
if
(
value
=
=
NULL
)
addReply
(
c
,
shared
.
nullbulk
)
;
else
addReplyBulkCBuffer
(
c
,
value
,
sdslen
(
value
)
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
hgetCommand
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
nullbulk
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addHashFieldToReply
(
c
,
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
;
}
void
hmgetCommand
(
client
*
c
)
{
robj
*
o
;
int
i
;
o
=
lookupKeyRead
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
if
(
o
!
=
NULL
&
&
o
-
>
type
!
=
OBJ_HASH
)
{
addReply
(
c
,
shared
.
wrongtypeerr
)
;
return
;
}
addReplyMultiBulkLen
(
c
,
c
-
>
argc
-
<int>
)
;
for
(
i
=
<int>
;
i
<
c
-
>
argc
;
i
+
+
)
{
addHashFieldToReply
(
c
,
o
,
c
-
>
argv
[
i
]
-
>
ptr
)
;
}
}
void
hdelCommand
(
client
*
c
)
{
robj
*
o
;
int
j
,
deleted
=
<int>
,
keyremoved
=
<int>
;
if
(
(
o
=
lookupKeyWriteOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
for
(
j
=
<int>
;
j
<
c
-
>
argc
;
j
+
+
)
{
if
(
hashTypeDelete
(
o
,
c
-
>
argv
[
j
]
-
>
ptr
)
)
{
deleted
+
+
;
if
(
hashTypeLength
(
o
)
=
=
<int>
)
{
dbDelete
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
keyremoved
=
<int>
;
break
;
}
}
}
if
(
deleted
)
{
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
if
(
keyremoved
)
notifyKeyspaceEvent
(
NOTIFY_GENERIC
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
=
deleted
;
}
addReplyLongLong
(
c
,
deleted
)
;
}
void
hlenCommand
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReplyLongLong
(
c
,
hashTypeLength
(
o
)
)
;
}
void
hstrlenCommand
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReplyLongLong
(
c
,
hashTypeGetValueLength
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
)
;
}
static
void
addHashIteratorCursorToReply
(
client
*
c
,
hashTypeIterator
*
hi
,
int
what
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
hashTypeCurrentFromZiplist
(
hi
,
what
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
vstr
)
addReplyBulkCBuffer
(
c
,
vstr
,
vlen
)
;
else
addReplyBulkLongLong
(
c
,
vll
)
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
=
hashTypeCurrentFromHashTable
(
hi
,
what
)
;
addReplyBulkCBuffer
(
c
,
value
,
sdslen
(
value
)
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
genericHgetallCommand
(
client
*
c
,
int
flags
)
{
robj
*
o
;
hashTypeIterator
*
hi
;
int
multiplier
=
<int>
;
int
length
,
count
=
<int>
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
emptymultibulk
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
if
(
flags
&
OBJ_HASH_KEY
)
multiplier
+
+
;
if
(
flags
&
OBJ_HASH_VALUE
)
multiplier
+
+
;
length
=
hashTypeLength
(
o
)
*
multiplier
;
addReplyMultiBulkLen
(
c
,
length
)
;
hi
=
hashTypeInitIterator
(
o
)
;
while
(
hashTypeNext
(
hi
)
!
=
C_ERR
)
{
if
(
flags
&
OBJ_HASH_KEY
)
{
addHashIteratorCursorToReply
(
c
,
hi
,
OBJ_HASH_KEY
)
;
count
+
+
;
}
if
(
flags
&
OBJ_HASH_VALUE
)
{
addHashIteratorCursorToReply
(
c
,
hi
,
OBJ_HASH_VALUE
)
;
count
+
+
;
}
}
hashTypeReleaseIterator
(
hi
)
;
serverAssert
(
count
=
=
length
)
;
}
void
hkeysCommand
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_KEY
)
;
}
void
hvalsCommand
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_VALUE
)
;
}
void
hgetallCommand
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_KEY
|
OBJ_HASH_VALUE
)
;
}
void
hexistsCommand
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReply
(
c
,
hashTypeExists
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
?
shared
.
cone
:
shared
.
czero
)
;
}
void
hscanCommand
(
client
*
c
)
{
robj
*
o
;
unsigned
long
cursor
;
if
(
parseScanCursorOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
&
cursor
)
=
=
C_ERR
)
return
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
emptyscan
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
scanGenericCommand
(
c
,
o
,
cursor
)
;
}
<UNK>
<UNK>
<EOF>
