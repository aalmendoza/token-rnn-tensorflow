<START>
struct
<UNK>
shared
;
<UNK>
R_Zero
,
<UNK>
,
<UNK>
,
<UNK>
;
struct
<UNK>
server
;
struct
<UNK>
<UNK>
[
]
=
{
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
<UNK>
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
-
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
,
{
<str>
,
<UNK>
,
-
<int>
,
<str>
,
<int>
,
NULL
,
<int>
,
<int>
,
<int>
,
<int>
,
<int>
}
}
;
struct
<UNK>
*
<UNK>
(
void
)
;
void
<UNK>
(
int
level
,
const
char
*
msg
)
{
const
int
<UNK>
[
]
=
{
<UNK>
,
<UNK>
,
<UNK>
,
<UNK>
}
;
const
char
*
c
=
<str>
;
FILE
*
fp
;
char
buf
[
<int>
]
;
int
<UNK>
=
(
level
&
<UNK>
)
;
int
log_to_stdout
=
server
.
logfile
[
<int>
]
=
=
<str>
;
level
&
=
<UNK>
;
if
(
level
<
server
.
<UNK>
)
return
;
fp
=
log_to_stdout
?
<UNK>
:
<UNK>
(
server
.
logfile
,
<str>
)
;
if
(
!
fp
)
return
;
if
(
<UNK>
)
{
<UNK>
(
fp
,
<str>
,
msg
)
;
}
else
{
int
off
;
struct
<UNK>
tv
;
int
role_char
;
<UNK>
pid
=
<UNK>
(
)
;
<UNK>
(
&
tv
,
NULL
)
;
off
=
<UNK>
(
buf
,
sizeof
(
buf
)
,
<str>
,
<UNK>
(
&
tv
.
<UNK>
)
)
;
<UNK>
(
buf
+
off
,
sizeof
(
buf
)
-
off
,
<str>
,
(
int
)
tv
.
<UNK>
/
<int>
)
;
if
(
server
.
<UNK>
)
{
role_char
=
<str>
;
}
else
if
(
pid
!
=
server
.
pid
)
{
role_char
=
<str>
;
}
else
{
role_char
=
(
server
.
<UNK>
?
<str>
:
<str>
)
;
}
<UNK>
(
fp
,
<str>
,
(
int
)
<UNK>
(
)
,
role_char
,
buf
,
c
[
level
]
,
msg
)
;
}
<UNK>
(
fp
)
;
if
(
!
log_to_stdout
)
<UNK>
(
fp
)
;
if
(
server
.
<UNK>
)
<UNK>
(
<UNK>
[
level
]
,
<str>
,
msg
)
;
}
void
serverLog
(
int
level
,
const
char
*
<UNK>
,
.
.
.
)
{
<UNK>
<UNK>
;
char
msg
[
<UNK>
]
;
if
(
(
level
&
<UNK>
)
<
server
.
<UNK>
)
return
;
<UNK>
(
<UNK>
,
<UNK>
)
;
<UNK>
(
msg
,
sizeof
(
msg
)
,
<UNK>
,
<UNK>
)
;
<UNK>
(
<UNK>
)
;
<UNK>
(
level
,
msg
)
;
}
void
<UNK>
(
int
level
,
const
char
*
msg
)
{
int
fd
;
int
log_to_stdout
=
server
.
logfile
[
<int>
]
=
=
<str>
;
char
buf
[
<int>
]
;
if
(
(
level
&
<UNK>
)
<
server
.
<UNK>
|
|
(
log_to_stdout
&
&
server
.
<UNK>
)
)
return
;
fd
=
log_to_stdout
?
<UNK>
:
<UNK>
(
server
.
logfile
,
<UNK>
|
<UNK>
|
<UNK>
,
<UNK>
)
;
if
(
fd
=
=
-
<int>
)
return
;
<UNK>
(
buf
,
sizeof
(
buf
)
,
<UNK>
(
)
)
;
if
(
write
(
fd
,
buf
,
strlen
(
buf
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
<UNK>
(
buf
,
sizeof
(
buf
)
,
time
(
NULL
)
)
;
if
(
write
(
fd
,
buf
,
strlen
(
buf
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
msg
,
strlen
(
msg
)
)
=
=
-
<int>
)
goto
err
;
if
(
write
(
fd
,
<str>
,
<int>
)
=
=
-
<int>
)
goto
err
;
err
:
if
(
!
log_to_stdout
)
<UNK>
(
fd
)
;
}
long
long
<UNK>
(
void
)
{
struct
<UNK>
tv
;
long
long
<UNK>
;
<UNK>
(
&
tv
,
NULL
)
;
<UNK>
=
(
(
long
long
)
tv
.
<UNK>
)
*
<int>
;
<UNK>
+
=
tv
.
<UNK>
;
return
<UNK>
;
}
<UNK>
mstime
(
void
)
{
return
<UNK>
(
)
/
<int>
;
}
void
<UNK>
(
int
<UNK>
)
{
exit
(
<UNK>
)
;
<UNK>
(
<UNK>
)
;
}
void
<UNK>
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
<UNK>
(
val
)
;
}
void
<UNK>
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
<UNK>
(
(
<UNK>
*
)
val
)
;
}
int
dictSdsKeyCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
int
<UNK>
,
<UNK>
;
DICT_NOTUSED
(
privdata
)
;
<UNK>
=
sdslen
(
(
sds
)
key1
)
;
<UNK>
=
sdslen
(
(
sds
)
key2
)
;
if
(
<UNK>
!
=
<UNK>
)
return
<int>
;
return
<UNK>
(
key1
,
key2
,
<UNK>
)
=
=
<int>
;
}
int
dictSdsKeyCaseCompare
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
DICT_NOTUSED
(
privdata
)
;
return
<UNK>
(
key1
,
key2
)
=
=
<int>
;
}
void
dictObjectDestructor
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
if
(
val
=
=
NULL
)
return
;
decrRefCount
(
val
)
;
}
void
dictSdsDestructor
(
void
*
privdata
,
void
*
val
)
{
DICT_NOTUSED
(
privdata
)
;
<UNK>
(
val
)
;
}
int
<UNK>
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
const
robj
*
o1
=
key1
,
*
o2
=
key2
;
return
dictSdsKeyCompare
(
privdata
,
o1
-
>
ptr
,
o2
-
>
ptr
)
;
}
unsigned
int
<UNK>
(
const
void
*
key
)
{
const
robj
*
o
=
key
;
return
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
}
unsigned
int
dictSdsHash
(
const
void
*
key
)
{
return
dictGenHashFunction
(
(
unsigned
char
*
)
key
,
sdslen
(
(
char
*
)
key
)
)
;
}
unsigned
int
dictSdsCaseHash
(
const
void
*
key
)
{
return
<UNK>
(
(
unsigned
char
*
)
key
,
sdslen
(
(
char
*
)
key
)
)
;
}
int
<UNK>
(
void
*
privdata
,
const
void
*
key1
,
const
void
*
key2
)
{
robj
*
o1
=
(
robj
*
)
key1
,
*
o2
=
(
robj
*
)
key2
;
int
<UNK>
;
if
(
o1
-
>
encoding
=
=
<UNK>
&
&
o2
-
>
encoding
=
=
<UNK>
)
return
o1
-
>
ptr
=
=
o2
-
>
ptr
;
o1
=
<UNK>
(
o1
)
;
o2
=
<UNK>
(
o2
)
;
<UNK>
=
dictSdsKeyCompare
(
privdata
,
o1
-
>
ptr
,
o2
-
>
ptr
)
;
decrRefCount
(
o1
)
;
decrRefCount
(
o2
)
;
return
<UNK>
;
}
unsigned
int
<UNK>
(
const
void
*
key
)
{
robj
*
o
=
(
robj
*
)
key
;
if
(
<UNK>
(
o
)
)
{
return
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
}
else
{
if
(
o
-
>
encoding
=
=
<UNK>
)
{
char
buf
[
<int>
]
;
int
len
;
len
=
<UNK>
(
buf
,
<int>
,
(
long
)
o
-
>
ptr
)
;
return
dictGenHashFunction
(
(
unsigned
char
*
)
buf
,
len
)
;
}
else
{
unsigned
int
<UNK>
;
o
=
<UNK>
(
o
)
;
<UNK>
=
dictGenHashFunction
(
o
-
>
ptr
,
sdslen
(
(
sds
)
o
-
>
ptr
)
)
;
decrRefCount
(
o
)
;
return
<UNK>
;
}
}
}
dictType
<UNK>
=
{
<UNK>
,
NULL
,
NULL
,
<UNK>
,
dictObjectDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
NULL
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
dictObjectDestructor
}
;
dictType
<UNK>
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
dictObjectDestructor
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
NULL
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
dictSdsDestructor
}
;
dictType
<UNK>
=
{
<UNK>
,
NULL
,
NULL
,
<UNK>
,
dictObjectDestructor
,
<UNK>
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsHash
,
NULL
,
NULL
,
dictSdsKeyCompare
,
dictSdsDestructor
,
NULL
}
;
dictType
<UNK>
=
{
dictSdsCaseHash
,
NULL
,
NULL
,
dictSdsKeyCaseCompare
,
dictSdsDestructor
,
NULL
}
;
int
<UNK>
(
dict
*
dict
)
{
long
long
size
,
used
;
size
=
<UNK>
(
dict
)
;
used
=
dictSize
(
dict
)
;
return
(
size
&
&
used
&
&
size
>
<UNK>
&
&
(
used
*
<int>
/
size
<
<UNK>
)
)
;
}
void
<UNK>
(
int
dbid
)
{
if
(
<UNK>
(
server
.
db
[
dbid
]
.
dict
)
)
<UNK>
(
server
.
db
[
dbid
]
.
dict
)
;
if
(
<UNK>
(
server
.
db
[
dbid
]
.
expires
)
)
<UNK>
(
server
.
db
[
dbid
]
.
expires
)
;
}
int
<UNK>
(
int
dbid
)
{
if
(
<UNK>
(
server
.
db
[
dbid
]
.
dict
)
)
{
<UNK>
(
server
.
db
[
dbid
]
.
dict
,
<int>
)
;
return
<int>
;
}
if
(
<UNK>
(
server
.
db
[
dbid
]
.
expires
)
)
{
<UNK>
(
server
.
db
[
dbid
]
.
expires
,
<int>
)
;
return
<int>
;
}
return
<int>
;
}
void
<UNK>
(
void
)
{
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
)
<UNK>
(
)
;
else
<UNK>
(
)
;
}
int
<UNK>
(
<UNK>
*
db
,
<UNK>
*
de
,
long
long
now
)
{
long
long
t
=
<UNK>
(
de
)
;
if
(
now
>
t
)
{
sds
key
=
<UNK>
(
de
)
;
robj
*
keyobj
=
createStringObject
(
key
,
sdslen
(
key
)
)
;
<UNK>
(
db
,
keyobj
,
server
.
<UNK>
)
;
if
(
server
.
<UNK>
)
<UNK>
(
db
,
keyobj
)
;
else
<UNK>
(
db
,
keyobj
)
;
notifyKeyspaceEvent
(
<UNK>
,
<str>
,
keyobj
,
db
-
>
id
)
;
decrRefCount
(
keyobj
)
;
server
.
<UNK>
+
+
;
return
<int>
;
}
else
{
return
<int>
;
}
}
void
<UNK>
(
int
type
)
{
static
unsigned
int
<UNK>
=
<int>
;
static
int
timelimit_exit
=
<int>
;
static
long
long
<UNK>
=
<int>
;
int
j
,
<UNK>
=
<int>
;
int
dbs_per_call
=
<UNK>
;
long
long
start
=
<UNK>
(
)
,
timelimit
;
if
(
type
=
=
<UNK>
)
{
if
(
!
timelimit_exit
)
return
;
if
(
start
<
<UNK>
+
<UNK>
*
<int>
)
return
;
<UNK>
=
start
;
}
if
(
dbs_per_call
>
server
.
dbnum
|
|
timelimit_exit
)
dbs_per_call
=
server
.
dbnum
;
timelimit
=
<int>
*
<UNK>
/
server
.
<UNK>
/
<int>
;
timelimit_exit
=
<int>
;
if
(
timelimit
<
=
<int>
)
timelimit
=
<int>
;
if
(
type
=
=
<UNK>
)
timelimit
=
<UNK>
;
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
int
<UNK>
;
<UNK>
*
db
=
server
.
db
+
(
<UNK>
%
server
.
dbnum
)
;
<UNK>
+
+
;
<UNK>
{
unsigned
long
num
,
<UNK>
;
long
long
now
,
<UNK>
;
int
ttl_samples
;
if
(
(
num
=
dictSize
(
db
-
>
expires
)
)
=
=
<int>
)
{
db
-
>
avg_ttl
=
<int>
;
break
;
}
<UNK>
=
<UNK>
(
db
-
>
expires
)
;
now
=
mstime
(
)
;
if
(
num
&
&
<UNK>
>
<UNK>
&
&
(
num
*
<int>
/
<UNK>
<
<int>
)
)
break
;
<UNK>
=
<int>
;
<UNK>
=
<int>
;
ttl_samples
=
<int>
;
if
(
num
>
<UNK>
)
num
=
<UNK>
;
while
(
num
-
-
)
{
<UNK>
*
de
;
long
long
<UNK>
;
if
(
(
de
=
<UNK>
(
db
-
>
expires
)
)
=
=
NULL
)
break
;
<UNK>
=
<UNK>
(
de
)
-
now
;
if
(
<UNK>
(
db
,
de
,
now
)
)
<UNK>
+
+
;
if
(
<UNK>
>
<int>
)
{
<UNK>
+
=
<UNK>
;
ttl_samples
+
+
;
}
}
if
(
ttl_samples
)
{
long
long
avg_ttl
=
<UNK>
/
ttl_samples
;
if
(
db
-
>
avg_ttl
=
=
<int>
)
db
-
>
avg_ttl
=
avg_ttl
;
db
-
>
avg_ttl
=
(
db
-
>
avg_ttl
/
<int>
)
*
<int>
+
(
avg_ttl
/
<int>
)
;
}
<UNK>
+
+
;
if
(
(
<UNK>
&
<UNK>
)
=
=
<int>
)
{
long
long
<UNK>
=
<UNK>
(
)
-
start
;
<UNK>
(
<str>
,
<UNK>
/
<int>
)
;
if
(
<UNK>
>
timelimit
)
timelimit_exit
=
<int>
;
}
if
(
timelimit_exit
)
return
;
}
while
(
<UNK>
>
<UNK>
/
<int>
)
;
}
}
unsigned
int
<UNK>
(
void
)
{
return
(
mstime
(
)
/
<UNK>
)
&
<UNK>
;
}
void
trackInstantaneousMetric
(
int
metric
,
long
long
<UNK>
)
{
long
long
t
=
mstime
(
)
-
server
.
inst_metric
[
metric
]
.
<UNK>
;
long
long
<UNK>
=
<UNK>
-
server
.
inst_metric
[
metric
]
.
<UNK>
;
long
long
<UNK>
;
<UNK>
=
t
>
<int>
?
(
<UNK>
*
<int>
/
t
)
:
<int>
;
server
.
inst_metric
[
metric
]
.
<UNK>
[
server
.
inst_metric
[
metric
]
.
<UNK>
]
=
<UNK>
;
server
.
inst_metric
[
metric
]
.
<UNK>
+
+
;
server
.
inst_metric
[
metric
]
.
<UNK>
%
=
<UNK>
;
server
.
inst_metric
[
metric
]
.
<UNK>
=
mstime
(
)
;
server
.
inst_metric
[
metric
]
.
<UNK>
=
<UNK>
;
}
long
long
<UNK>
(
int
metric
)
{
int
j
;
long
long
<UNK>
=
<int>
;
for
(
j
=
<int>
;
j
<
<UNK>
;
j
+
+
)
<UNK>
+
=
server
.
inst_metric
[
metric
]
.
<UNK>
[
j
]
;
return
<UNK>
/
<UNK>
;
}
int
<UNK>
(
client
*
c
,
<UNK>
<UNK>
)
{
<UNK>
now
=
<UNK>
/
<int>
;
if
(
server
.
<UNK>
&
&
!
(
c
-
>
flags
&
<UNK>
)
&
&
!
(
c
-
>
flags
&
<UNK>
)
&
&
!
(
c
-
>
flags
&
<UNK>
)
&
&
!
(
c
-
>
flags
&
<UNK>
)
&
&
(
now
-
c
-
>
<UNK>
>
server
.
<UNK>
)
)
{
serverLog
(
<UNK>
,
<str>
)
;
<UNK>
(
c
)
;
return
<int>
;
}
else
if
(
c
-
>
flags
&
<UNK>
)
{
if
(
c
-
>
<UNK>
.
<UNK>
!
=
<int>
&
&
c
-
>
<UNK>
.
<UNK>
<
<UNK>
)
{
<UNK>
(
c
)
;
<UNK>
(
c
)
;
}
else
if
(
server
.
cluster_enabled
)
{
if
(
<UNK>
(
c
)
)
<UNK>
(
c
)
;
}
}
return
<int>
;
}
int
<UNK>
(
client
*
c
)
{
size_t
querybuf_size
=
<UNK>
(
c
-
>
querybuf
)
;
<UNK>
<UNK>
=
server
.
unixtime
-
c
-
>
<UNK>
;
if
(
(
(
querybuf_size
>
<UNK>
)
&
&
(
querybuf_size
/
(
c
-
>
<UNK>
+
<int>
)
)
>
<int>
)
|
|
(
querybuf_size
>
<int>
&
&
<UNK>
>
<int>
)
)
{
if
(
<UNK>
(
c
-
>
querybuf
)
>
<int>
)
{
c
-
>
querybuf
=
<UNK>
(
c
-
>
querybuf
)
;
}
}
c
-
>
<UNK>
=
<int>
;
return
<int>
;
}
void
<UNK>
(
void
)
{
int
numclients
=
listLength
(
server
.
clients
)
;
int
iterations
=
numclients
/
server
.
<UNK>
;
<UNK>
now
=
mstime
(
)
;
if
(
iterations
<
<UNK>
)
iterations
=
(
numclients
<
<UNK>
)
?
numclients
:
<UNK>
;
while
(
listLength
(
server
.
clients
)
&
&
iterations
-
-
)
{
client
*
c
;
<UNK>
*
<UNK>
;
<UNK>
(
server
.
clients
)
;
<UNK>
=
<UNK>
(
server
.
clients
)
;
c
=
<UNK>
(
<UNK>
)
;
if
(
<UNK>
(
c
,
now
)
)
<UNK>
;
if
(
<UNK>
(
c
)
)
<UNK>
;
}
}
void
<UNK>
(
void
)
{
if
(
server
.
<UNK>
&
&
server
.
<UNK>
=
=
NULL
)
<UNK>
(
<UNK>
)
;
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
)
{
static
unsigned
int
<UNK>
=
<int>
;
static
unsigned
int
<UNK>
=
<int>
;
int
dbs_per_call
=
<UNK>
;
int
j
;
if
(
dbs_per_call
>
server
.
dbnum
)
dbs_per_call
=
server
.
dbnum
;
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
<UNK>
(
<UNK>
%
server
.
dbnum
)
;
<UNK>
+
+
;
}
if
(
server
.
<UNK>
)
{
for
(
j
=
<int>
;
j
<
dbs_per_call
;
j
+
+
)
{
int
<UNK>
=
<UNK>
(
<UNK>
%
server
.
dbnum
)
;
<UNK>
+
+
;
if
(
<UNK>
)
{
break
;
}
}
}
}
}
void
<UNK>
(
void
)
{
server
.
unixtime
=
time
(
NULL
)
;
server
.
mstime
=
mstime
(
)
;
}
int
<UNK>
(
struct
<UNK>
*
eventLoop
,
long
long
id
,
void
*
<UNK>
)
{
int
j
;
UNUSED
(
eventLoop
)
;
UNUSED
(
id
)
;
UNUSED
(
<UNK>
)
;
if
(
server
.
<UNK>
)
<UNK>
(
server
.
<UNK>
)
;
<UNK>
(
)
;
run_with_period
(
<int>
)
{
trackInstantaneousMetric
(
<UNK>
,
server
.
<UNK>
)
;
trackInstantaneousMetric
(
<UNK>
,
server
.
<UNK>
)
;
trackInstantaneousMetric
(
<UNK>
,
server
.
<UNK>
)
;
}
server
.
<UNK>
=
<UNK>
(
)
;
if
(
<UNK>
(
)
>
server
.
<UNK>
)
server
.
<UNK>
=
<UNK>
(
)
;
server
.
<UNK>
=
<UNK>
(
)
;
if
(
server
.
<UNK>
)
{
if
(
<UNK>
(
<UNK>
)
=
=
C_OK
)
exit
(
<int>
)
;
serverLog
(
LL_WARNING
,
<str>
)
;
server
.
<UNK>
=
<int>
;
}
run_with_period
(
<int>
)
{
for
(
j
=
<int>
;
j
<
server
.
dbnum
;
j
+
+
)
{
long
long
size
,
used
,
vkeys
;
size
=
<UNK>
(
server
.
db
[
j
]
.
dict
)
;
used
=
dictSize
(
server
.
db
[
j
]
.
dict
)
;
vkeys
=
dictSize
(
server
.
db
[
j
]
.
expires
)
;
if
(
used
|
|
vkeys
)
{
serverLog
(
<UNK>
,
<str>
,
j
,
used
,
vkeys
,
size
)
;
}
}
}
if
(
!
server
.
<UNK>
)
{
run_with_period
(
<int>
)
{
serverLog
(
<UNK>
,
<str>
,
listLength
(
server
.
clients
)
-
listLength
(
server
.
<UNK>
)
,
listLength
(
server
.
<UNK>
)
,
<UNK>
(
)
)
;
}
}
<UNK>
(
)
;
<UNK>
(
)
;
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
&
&
server
.
<UNK>
)
{
<UNK>
(
)
;
}
if
(
server
.
rdb_child_pid
!
=
-
<int>
|
|
server
.
aof_child_pid
!
=
-
<int>
|
|
<UNK>
(
)
)
{
int
statloc
;
<UNK>
pid
;
if
(
(
pid
=
<UNK>
(
&
statloc
,
<UNK>
,
NULL
)
)
!
=
<int>
)
{
int
<UNK>
=
<UNK>
(
statloc
)
;
int
bysignal
=
<int>
;
if
(
<UNK>
(
statloc
)
)
bysignal
=
<UNK>
(
statloc
)
;
if
(
pid
=
=
-
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
<str>
,
<UNK>
(
<UNK>
)
,
(
int
)
server
.
rdb_child_pid
,
(
int
)
server
.
aof_child_pid
)
;
}
else
if
(
pid
=
=
server
.
rdb_child_pid
)
{
<UNK>
(
<UNK>
,
bysignal
)
;
}
else
if
(
pid
=
=
server
.
aof_child_pid
)
{
<UNK>
(
<UNK>
,
bysignal
)
;
}
else
{
if
(
!
<UNK>
(
pid
)
)
{
serverLog
(
LL_WARNING
,
<str>
,
(
long
)
pid
)
;
}
}
<UNK>
(
)
;
}
}
else
{
for
(
j
=
<int>
;
j
<
server
.
<UNK>
;
j
+
+
)
{
struct
<UNK>
*
sp
=
server
.
<UNK>
+
j
;
if
(
server
.
dirty
>
=
sp
-
>
<UNK>
&
&
server
.
unixtime
-
server
.
<UNK>
>
sp
-
>
<UNK>
&
&
(
server
.
unixtime
-
server
.
<UNK>
>
<UNK>
|
|
server
.
<UNK>
=
=
C_OK
)
)
{
serverLog
(
<UNK>
,
<str>
,
sp
-
>
<UNK>
,
(
int
)
sp
-
>
<UNK>
)
;
<UNK>
(
server
.
<UNK>
)
;
break
;
}
}
if
(
server
.
rdb_child_pid
=
=
-
<int>
&
&
server
.
aof_child_pid
=
=
-
<int>
&
&
server
.
<UNK>
&
&
server
.
<UNK>
>
server
.
<UNK>
)
{
long
long
<UNK>
=
server
.
<UNK>
?
server
.
<UNK>
:
<int>
;
long
long
<UNK>
=
(
server
.
<UNK>
*
<int>
/
<UNK>
)
-
<int>
;
if
(
<UNK>
>
=
server
.
<UNK>
)
{
serverLog
(
<UNK>
,
<str>
,
<UNK>
)
;
<UNK>
(
)
;
}
}
}
if
(
server
.
<UNK>
)
<UNK>
(
<int>
)
;
run_with_period
(
<int>
)
{
if
(
server
.
<UNK>
=
=
C_ERR
)
<UNK>
(
<int>
)
;
}
<UNK>
(
)
;
<UNK>
(
)
;
run_with_period
(
<int>
)
<UNK>
(
)
;
run_with_period
(
<int>
)
{
if
(
server
.
cluster_enabled
)
<UNK>
(
)
;
}
run_with_period
(
<int>
)
{
if
(
server
.
<UNK>
)
<UNK>
(
)
;
}
run_with_period
(
<int>
)
{
<UNK>
(
)
;
}
server
.
<UNK>
+
+
;
return
<int>
/
server
.
<UNK>
;
}
void
<UNK>
(
struct
<UNK>
*
eventLoop
)
{
UNUSED
(
eventLoop
)
;
if
(
server
.
cluster_enabled
)
<UNK>
(
)
;
if
(
server
.
<UNK>
&
&
server
.
<UNK>
=
=
NULL
)
<UNK>
(
<UNK>
)
;
if
(
server
.
<UNK>
)
{
robj
*
argv
[
<int>
]
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
argv
[
<int>
]
=
createStringObject
(
<str>
,
<int>
)
;
<UNK>
(
server
.
<UNK>
,
server
.
<UNK>
,
argv
,
<int>
)
;
decrRefCount
(
argv
[
<int>
]
)
;
decrRefCount
(
argv
[
<int>
]
)
;
decrRefCount
(
argv
[
<int>
]
)
;
server
.
<UNK>
=
<int>
;
}
if
(
listLength
(
server
.
<UNK>
)
)
<UNK>
(
)
;
if
(
listLength
(
server
.
<UNK>
)
)
<UNK>
(
)
;
<UNK>
(
<int>
)
;
<UNK>
(
)
;
}
void
<UNK>
(
void
)
{
int
j
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
err
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
czero
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
cone
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
nullbulk
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
shared
.
<UNK>
=
createObject
(
OBJ_STRING
,
sdsnew
(
<str>
)
)
;
for
(
j
=
<int>
;
j
<
<UNK>
;
j
+
+
)
{
char
dictid_str
[
<int>
]
;
int
<UNK>
;
<UNK>
=
<UNK>
(
dictid_str
,
sizeof
(
dictid_str
)
,
j
)
;
shared
.
<UNK>
[
j
]
=
createObject
(
OBJ_STRING
,
<UNK>
(
<UNK>
(
)
,
<str>
,
<UNK>
,
dictid_str
)
)
;
}
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
shared
.
<UNK>
=
createStringObject
(
<str>
,
<int>
)
;
for
(
j
=
<int>
;
j
<
<UNK>
;
j
+
+
)
{
shared
.
<UNK>
[
j
]
=
<UNK>
(
createObject
(
OBJ_STRING
,
(
void
*
)
(
long
)
j
)
)
;
shared
.
<UNK>
[
j
]
-
>
encoding
=
<UNK>
;
}
for
(
j
=
<int>
;
j
<
<UNK>
;
j
+
+
)
{
shared
.
<UNK>
[
j
]
=
createObject
(
OBJ_STRING
,
<UNK>
(
<UNK>
(
)
,
<str>
,
j
)
)
;
shared
.
<UNK>
[
j
]
=
createObject
(
OBJ_STRING
,
<UNK>
(
<UNK>
(
)
,
<str>
,
j
)
)
;
}
shared
.
<UNK>
=
sdsnew
(
<str>
)
;
shared
.
<UNK>
=
sdsnew
(
<str>
)
;
}
void
<UNK>
(
void
)
{
int
j
;
<UNK>
(
server
.
<UNK>
,
<UNK>
)
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
[
<UNK>
]
=
<str>
;
server
.
<UNK>
=
(
sizeof
(
long
)
=
=
<int>
)
?
<int>
:
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
dbnum
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<int>
;
server
.
logfile
=
zstrdup
(
<UNK>
)
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
zstrdup
(
<UNK>
)
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
time
(
NULL
)
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
C_OK
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
zstrdup
(
<UNK>
)
;
server
.
<UNK>
=
zstrdup
(
<UNK>
)
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
cluster_enabled
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
zstrdup
(
<UNK>
)
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
(
&
<UNK>
,
NULL
)
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
(
<int>
*
<int>
*
<int>
)
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
(
)
;
<UNK>
(
)
;
<UNK>
(
<int>
*
<int>
,
<int>
)
;
<UNK>
(
<int>
,
<int>
)
;
<UNK>
(
<int>
,
<int>
)
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
-
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
NULL
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<int>
;
server
.
<UNK>
=
<UNK>
;
server
.
<UNK>
=
time
(
NULL
)
;
for
(
j
=
<int>
;
j
<
<UNK>
;
j
+
+
)
server
.
<UNK>
[
j
]
=
<UNK>
[
j
]
;
R_Zero
=
<UNK>
;
<UNK>
=
<UNK>
/
R_Zero
;
<UNK>
=
-
<UNK>
/
R_Zero
;
<UNK>
=
R_Zero
/
R_Zero
;
<EOF>
<START>
unsigned
int
<UNK>
(
const
void
*
const
<UNK>
,
unsigned
int
<UNK>
,
void
*
<UNK>
,
unsigned
int
<UNK>
,
<UNK>
htab
)
{
<UNK>
htab
;
const
u8
*
ip
=
(
const
u8
*
)
<UNK>
;
u8
*
op
=
(
u8
*
)
<UNK>
;
const
u8
*
in_end
=
ip
+
<UNK>
;
u8
*
out_end
=
op
+
<UNK>
;
const
u8
*
ref
;
unsigned
<UNK>
off
;
unsigned
long
off
;
unsigned
int
hval
;
int
lit
;
if
(
!
<UNK>
|
|
!
<UNK>
)
return
<int>
;
<UNK>
(
htab
,
<int>
,
sizeof
(
htab
)
)
;
lit
=
<int>
;
op
+
+
;
hval
=
<UNK>
(
ip
)
;
while
(
ip
<
in_end
-
<int>
)
{
<UNK>
*
hslot
;
hval
=
NEXT
(
hval
,
ip
)
;
hslot
=
htab
+
IDX
(
hval
)
;
ref
=
*
hslot
+
LZF_HSLOT_BIAS
;
*
hslot
=
ip
-
LZF_HSLOT_BIAS
;
if
(
<int>
&
&
ref
<
ip
&
&
(
off
=
ip
-
ref
-
<int>
)
<
<UNK>
&
&
ref
>
(
u8
*
)
<UNK>
&
&
ref
[
<int>
]
=
=
ip
[
<int>
]
&
&
(
(
ref
[
<int>
]
<
<
<int>
)
|
ref
[
<int>
]
)
=
=
(
(
ip
[
<int>
]
<
<
<int>
)
|
ip
[
<int>
]
)
&
&
*
(
<UNK>
*
)
ref
=
=
*
(
<UNK>
*
)
ip
)
{
unsigned
int
len
=
<int>
;
unsigned
int
maxlen
=
in_end
-
ip
-
len
;
maxlen
=
maxlen
>
<UNK>
?
<UNK>
:
maxlen
;
if
(
expect_false
(
op
+
<int>
+
<int>
>
=
out_end
)
)
if
(
op
-
!
lit
+
<int>
+
<int>
>
=
out_end
)
return
<int>
;
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
op
-
=
!
lit
;
for
(
;
;
)
{
if
(
<UNK>
(
maxlen
>
<int>
)
)
{
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
len
+
+
;
if
(
ref
[
len
]
!
=
ip
[
len
]
)
break
;
}
<UNK>
len
+
+
;
while
(
len
<
maxlen
&
&
ref
[
len
]
=
=
ip
[
len
]
)
;
break
;
}
len
-
=
<int>
;
ip
+
+
;
if
(
len
<
<int>
)
{
*
op
+
+
=
(
off
>
>
<int>
)
+
(
len
<
<
<int>
)
;
}
else
{
*
op
+
+
=
(
off
>
>
<int>
)
+
(
<int>
<
<
<int>
)
;
*
op
+
+
=
len
-
<int>
;
}
*
op
+
+
=
off
;
lit
=
<int>
;
op
+
+
;
ip
+
=
len
+
<int>
;
if
(
expect_false
(
ip
>
=
in_end
-
<int>
)
)
break
;
-
-
ip
;
-
-
ip
;
hval
=
<UNK>
(
ip
)
;
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
ip
-
=
len
+
<int>
;
<UNK>
{
hval
=
NEXT
(
hval
,
ip
)
;
htab
[
IDX
(
hval
)
]
=
ip
-
LZF_HSLOT_BIAS
;
ip
+
+
;
}
while
(
len
-
-
)
;
}
else
{
if
(
expect_false
(
op
>
=
out_end
)
)
return
<int>
;
lit
+
+
;
*
op
+
+
=
*
ip
+
+
;
if
(
expect_false
(
lit
=
=
<UNK>
)
)
{
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
lit
=
<int>
;
op
+
+
;
}
}
}
if
(
op
+
<int>
>
out_end
)
return
<int>
;
while
(
ip
<
in_end
)
{
lit
+
+
;
*
op
+
+
=
*
ip
+
+
;
if
(
expect_false
(
lit
=
=
<UNK>
)
)
{
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
lit
=
<int>
;
op
+
+
;
}
}
op
[
-
lit
-
<int>
]
=
lit
-
<int>
;
op
-
=
!
lit
;
return
op
-
(
u8
*
)
<UNK>
;
}
<EOF>
<START>
static
<UNK>
bio_threads
[
BIO_NUM_OPS
]
;
static
<UNK>
bio_mutex
[
BIO_NUM_OPS
]
;
static
<UNK>
bio_newjob_cond
[
BIO_NUM_OPS
]
;
static
<UNK>
bio_step_cond
[
BIO_NUM_OPS
]
;
static
<UNK>
*
bio_jobs
[
BIO_NUM_OPS
]
;
static
unsigned
long
long
bio_pending
[
BIO_NUM_OPS
]
;
struct
<UNK>
{
<UNK>
time
;
void
*
arg1
,
*
arg2
,
*
arg3
;
}
;
void
*
<UNK>
(
void
*
arg
)
;
void
<UNK>
(
robj
*
o
)
;
void
<UNK>
(
dict
*
<UNK>
,
dict
*
<UNK>
)
;
void
<UNK>
(
<UNK>
*
<UNK>
)
;
void
<UNK>
(
void
)
{
<UNK>
attr
;
<UNK>
<UNK>
;
size_t
stacksize
;
int
j
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
<UNK>
(
&
bio_mutex
[
j
]
,
NULL
)
;
<UNK>
(
&
bio_newjob_cond
[
j
]
,
NULL
)
;
<UNK>
(
&
bio_step_cond
[
j
]
,
NULL
)
;
bio_jobs
[
j
]
=
<UNK>
(
)
;
bio_pending
[
j
]
=
<int>
;
}
<UNK>
(
&
attr
)
;
<UNK>
(
&
attr
,
&
stacksize
)
;
if
(
!
stacksize
)
stacksize
=
<int>
;
while
(
stacksize
<
<UNK>
)
stacksize
*
=
<int>
;
<UNK>
(
&
attr
,
stacksize
)
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
void
*
arg
=
(
void
*
)
(
unsigned
long
)
j
;
if
(
<UNK>
(
&
<UNK>
,
&
attr
,
<UNK>
,
arg
)
!
=
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
)
;
exit
(
<int>
)
;
}
bio_threads
[
j
]
=
<UNK>
;
}
}
void
<UNK>
(
int
type
,
void
*
arg1
,
void
*
arg2
,
void
*
arg3
)
{
struct
<UNK>
*
job
=
<UNK>
(
sizeof
(
*
job
)
)
;
job
-
>
time
=
time
(
NULL
)
;
job
-
>
arg1
=
arg1
;
job
-
>
arg2
=
arg2
;
job
-
>
arg3
=
arg3
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
<UNK>
(
bio_jobs
[
type
]
,
job
)
;
bio_pending
[
type
]
+
+
;
<UNK>
(
&
bio_newjob_cond
[
type
]
)
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
}
void
*
<UNK>
(
void
*
arg
)
{
struct
<UNK>
*
job
;
unsigned
long
type
=
(
unsigned
long
)
arg
;
<UNK>
sigset
;
if
(
type
>
=
BIO_NUM_OPS
)
{
serverLog
(
LL_WARNING
,
<str>
,
type
)
;
return
NULL
;
}
<UNK>
(
<UNK>
,
NULL
)
;
<UNK>
(
<UNK>
,
NULL
)
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
<UNK>
(
&
sigset
)
;
<UNK>
(
&
sigset
,
<UNK>
)
;
if
(
<UNK>
(
<UNK>
,
&
sigset
,
NULL
)
)
serverLog
(
LL_WARNING
,
<str>
,
<UNK>
(
<UNK>
)
)
;
while
(
<int>
)
{
<UNK>
*
ln
;
if
(
listLength
(
bio_jobs
[
type
]
)
=
=
<int>
)
{
<UNK>
(
&
bio_newjob_cond
[
type
]
,
&
bio_mutex
[
type
]
)
;
<UNK>
;
}
ln
=
<UNK>
(
bio_jobs
[
type
]
)
;
job
=
ln
-
>
value
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
if
(
type
=
=
<UNK>
)
{
<UNK>
(
(
long
)
job
-
>
arg1
)
;
}
else
if
(
type
=
=
<UNK>
)
{
<UNK>
(
(
long
)
job
-
>
arg1
)
;
}
else
if
(
type
=
=
<UNK>
)
{
if
(
job
-
>
arg1
)
<UNK>
(
job
-
>
arg1
)
;
else
if
(
job
-
>
arg2
&
&
job
-
>
arg3
)
<UNK>
(
job
-
>
arg2
,
job
-
>
arg3
)
;
else
if
(
job
-
>
arg3
)
<UNK>
(
job
-
>
arg3
)
;
}
else
{
serverPanic
(
<str>
)
;
}
<UNK>
(
job
)
;
<UNK>
(
&
bio_step_cond
[
type
]
)
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
<UNK>
(
bio_jobs
[
type
]
,
ln
)
;
bio_pending
[
type
]
-
-
;
}
}
unsigned
long
long
<UNK>
(
int
type
)
{
unsigned
long
long
val
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
return
val
;
}
unsigned
long
long
<UNK>
(
int
type
)
{
unsigned
long
long
val
;
pthread_mutex_lock
(
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
if
(
val
!
=
<int>
)
{
<UNK>
(
&
bio_step_cond
[
type
]
,
&
bio_mutex
[
type
]
)
;
val
=
bio_pending
[
type
]
;
}
pthread_mutex_unlock
(
&
bio_mutex
[
type
]
)
;
return
val
;
}
void
<UNK>
(
void
)
{
int
err
,
j
;
for
(
j
=
<int>
;
j
<
BIO_NUM_OPS
;
j
+
+
)
{
if
(
<UNK>
(
bio_threads
[
j
]
)
=
=
<int>
)
{
if
(
(
err
=
<UNK>
(
bio_threads
[
j
]
,
NULL
)
)
!
=
<int>
)
{
serverLog
(
LL_WARNING
,
<str>
,
j
,
<UNK>
(
err
)
)
;
}
else
{
serverLog
(
LL_WARNING
,
<str>
,
j
)
;
}
}
}
}
<EOF>
<START>
static
char
error
[
<int>
]
;
static
off_t
<UNK>
;
int
<UNK>
(
char
*
buf
)
{
if
(
<UNK>
(
buf
,
<str>
,
<int>
)
!
=
<int>
)
{
ERROR
(
<str>
,
buf
[
<int>
]
,
buf
[
<int>
]
)
;
return
<int>
;
}
return
<int>
;
}
int
<UNK>
(
FILE
*
fp
,
char
<UNK>
,
long
*
target
)
{
char
buf
[
<int>
]
,
*
<UNK>
;
<UNK>
=
<UNK>
(
fp
)
;
if
(
<UNK>
(
buf
,
sizeof
(
buf
)
,
fp
)
=
=
NULL
)
{
return
<int>
;
}
if
(
buf
[
<int>
]
!
=
<UNK>
)
{
ERROR
(
<str>
,
buf
[
<int>
]
,
<UNK>
)
;
return
<int>
;
}
*
target
=
<UNK>
(
buf
+
<int>
,
&
<UNK>
,
<int>
)
;
return
<UNK>
(
<UNK>
)
;
}
int
<UNK>
(
FILE
*
fp
,
char
*
target
,
long
length
)
{
long
real
;
<UNK>
=
<UNK>
(
fp
)
;
real
=
<UNK>
(
target
,
<int>
,
length
,
fp
)
;
if
(
real
!
=
length
)
{
ERROR
(
<str>
,
length
,
real
)
;
return
<int>
;
}
return
<int>
;
}
int
<UNK>
(
FILE
*
fp
,
char
*
*
target
)
{
long
len
;
*
target
=
NULL
;
if
(
!
<UNK>
(
fp
,
<str>
,
&
len
)
)
{
return
<int>
;
}
len
+
=
<int>
;
*
target
=
(
char
*
)
<UNK>
(
len
)
;
if
(
!
<UNK>
(
fp
,
*
target
,
len
)
)
{
return
<int>
;
}
if
(
!
<UNK>
(
*
target
+
len
-
<int>
)
)
{
return
<int>
;
}
(
*
target
)
[
len
-
<int>
]
=
<str>
;
return
<int>
;
}
int
<UNK>
(
FILE
*
fp
,
long
*
target
)
{
return
<UNK>
(
fp
,
<str>
,
target
)
;
}
off_t
<UNK>
(
FILE
*
fp
)
{
long
argc
;
off_t
pos
=
<int>
;
int
i
,
multi
=
<int>
;
char
*
str
;
while
(
<int>
)
{
if
(
!
multi
)
pos
=
<UNK>
(
fp
)
;
if
(
!
<UNK>
(
fp
,
&
argc
)
)
break
;
for
(
i
=
<int>
;
i
<
argc
;
i
+
+
)
{
if
(
!
<UNK>
(
fp
,
&
str
)
)
break
;
if
(
i
=
=
<int>
)
{
if
(
<UNK>
(
str
,
<str>
)
=
=
<int>
)
{
if
(
multi
+
+
)
{
ERROR
(
<str>
)
;
break
;
}
}
else
if
(
<UNK>
(
str
,
<str>
)
=
=
<int>
)
{
if
(
-
-
multi
)
{
ERROR
(
<str>
)
;
break
;
}
}
}
<UNK>
(
str
)
;
}
if
(
i
<
argc
)
{
if
(
str
)
<UNK>
(
str
)
;
break
;
}
}
if
(
<UNK>
(
fp
)
&
&
multi
&
&
strlen
(
error
)
=
=
<int>
)
{
ERROR
(
<str>
)
;
}
if
(
strlen
(
error
)
>
<int>
)
{
printf
(
<str>
,
error
)
;
}
return
pos
;
}
int
<UNK>
(
int
argc
,
char
*
*
argv
)
{
char
*
filename
;
int
<UNK>
=
<int>
;
if
(
argc
<
<int>
)
{
printf
(
<str>
,
argv
[
<int>
]
)
;
exit
(
<int>
)
;
}
else
if
(
argc
=
=
<int>
)
{
filename
=
argv
[
<int>
]
;
}
else
if
(
argc
=
=
<int>
)
{
if
(
<UNK>
(
argv
[
<int>
]
,
<str>
)
!
=
<int>
)
{
printf
(
<str>
,
argv
[
<int>
]
)
;
exit
(
<int>
)
;
}
filename
=
argv
[
<int>
]
;
<UNK>
=
<int>
;
}
else
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
FILE
*
fp
=
<UNK>
(
filename
,
<str>
)
;
if
(
fp
=
=
NULL
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
struct
<UNK>
<UNK>
;
if
(
<UNK>
(
<UNK>
(
fp
)
,
&
<UNK>
)
=
=
-
<int>
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
off_t
size
=
<UNK>
.
<UNK>
;
if
(
size
=
=
<int>
)
{
printf
(
<str>
,
filename
)
;
exit
(
<int>
)
;
}
off_t
pos
=
<UNK>
(
fp
)
;
off_t
diff
=
size
-
pos
;
printf
(
<str>
,
(
long
long
)
size
,
(
long
long
)
pos
,
(
long
long
)
diff
)
;
if
(
diff
>
<int>
)
{
if
(
<UNK>
)
{
char
buf
[
<int>
]
;
printf
(
<str>
,
(
long
long
)
size
,
(
long
long
)
diff
,
(
long
long
)
pos
)
;
printf
(
<str>
)
;
if
(
<UNK>
(
buf
,
sizeof
(
buf
)
,
<UNK>
)
=
=
NULL
|
|
<UNK>
(
buf
,
<str>
,
<int>
)
!
=
<int>
)
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
if
(
<UNK>
(
<UNK>
(
fp
)
,
pos
)
=
=
-
<int>
)
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
else
{
printf
(
<str>
)
;
}
}
else
{
printf
(
<str>
)
;
exit
(
<int>
)
;
}
}
else
{
printf
(
<str>
)
;
}
<UNK>
(
fp
)
;
return
<int>
;
}
<EOF>
<START>
void
hashTypeTryConversion
(
robj
*
o
,
robj
*
*
argv
,
int
start
,
int
<UNK>
)
{
int
i
;
if
(
o
-
>
encoding
!
=
OBJ_ENCODING_ZIPLIST
)
return
;
for
(
i
=
start
;
i
<
=
<UNK>
;
i
+
+
)
{
if
(
<UNK>
(
argv
[
i
]
)
&
&
sdslen
(
argv
[
i
]
-
>
ptr
)
>
server
.
<UNK>
)
{
<UNK>
(
o
,
OBJ_ENCODING_HT
)
;
break
;
}
}
}
int
hashTypeGetFromZiplist
(
robj
*
o
,
sds
field
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
unsigned
char
*
zl
,
*
fptr
=
NULL
,
*
vptr
=
NULL
;
int
ret
;
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
<UNK>
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
<UNK>
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
}
}
if
(
vptr
!
=
NULL
)
{
ret
=
<UNK>
(
vptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
return
<int>
;
}
return
-
<int>
;
}
sds
hashTypeGetFromHashTable
(
robj
*
o
,
sds
field
)
{
<UNK>
*
de
;
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
;
de
=
<UNK>
(
o
-
>
ptr
,
field
)
;
if
(
de
=
=
NULL
)
return
NULL
;
return
dictGetVal
(
de
)
;
}
int
hashTypeGetValue
(
robj
*
o
,
sds
field
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
*
vstr
=
NULL
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
vstr
,
vlen
,
vll
)
=
=
<int>
)
return
C_OK
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
;
if
(
(
value
=
hashTypeGetFromHashTable
(
o
,
field
)
)
!
=
NULL
)
{
*
vstr
=
(
unsigned
char
*
)
value
;
*
vlen
=
sdslen
(
value
)
;
return
C_OK
;
}
}
else
{
serverPanic
(
<str>
)
;
}
return
C_ERR
;
}
robj
*
<UNK>
(
robj
*
o
,
sds
field
)
{
unsigned
char
*
vstr
;
unsigned
int
vlen
;
long
long
vll
;
if
(
hashTypeGetValue
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
C_ERR
)
return
NULL
;
if
(
vstr
)
return
createStringObject
(
(
char
*
)
vstr
,
vlen
)
;
else
return
<UNK>
(
vll
)
;
}
size_t
<UNK>
(
robj
*
o
,
sds
field
)
{
size_t
len
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
<int>
)
len
=
vstr
?
vlen
:
<UNK>
(
vll
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
aux
;
if
(
(
aux
=
hashTypeGetFromHashTable
(
o
,
field
)
)
!
=
NULL
)
len
=
sdslen
(
aux
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
len
;
}
int
<UNK>
(
robj
*
o
,
sds
field
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
if
(
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
=
=
<int>
)
return
<int>
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
hashTypeGetFromHashTable
(
o
,
field
)
!
=
NULL
)
return
<int>
;
}
else
{
serverPanic
(
<str>
)
;
}
return
<int>
;
}
int
hashTypeSet
(
robj
*
o
,
sds
field
,
sds
value
,
int
flags
)
{
int
update
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
,
*
fptr
,
*
vptr
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
<UNK>
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
<UNK>
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
update
=
<int>
;
zl
=
<UNK>
(
zl
,
&
vptr
)
;
zl
=
<UNK>
(
zl
,
vptr
,
(
unsigned
char
*
)
value
,
sdslen
(
value
)
)
;
}
}
if
(
!
update
)
{
zl
=
<UNK>
(
zl
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<UNK>
)
;
zl
=
<UNK>
(
zl
,
(
unsigned
char
*
)
value
,
sdslen
(
value
)
,
<UNK>
)
;
}
o
-
>
ptr
=
zl
;
if
(
hashTypeLength
(
o
)
>
server
.
<UNK>
)
<UNK>
(
o
,
OBJ_ENCODING_HT
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
<UNK>
*
de
=
<UNK>
(
o
-
>
ptr
,
field
)
;
if
(
de
)
{
<UNK>
(
dictGetVal
(
de
)
)
;
if
(
flags
&
HASH_SET_TAKE_VALUE
)
{
dictGetVal
(
de
)
=
value
;
value
=
NULL
;
}
else
{
dictGetVal
(
de
)
=
<UNK>
(
value
)
;
}
update
=
<int>
;
}
else
{
sds
f
,
v
;
if
(
flags
&
<UNK>
)
{
f
=
field
;
field
=
NULL
;
}
else
{
f
=
<UNK>
(
field
)
;
}
if
(
flags
&
HASH_SET_TAKE_VALUE
)
{
v
=
value
;
value
=
NULL
;
}
else
{
v
=
<UNK>
(
value
)
;
}
<UNK>
(
o
-
>
ptr
,
f
,
v
)
;
}
}
else
{
serverPanic
(
<str>
)
;
}
if
(
flags
&
<UNK>
&
&
field
)
<UNK>
(
field
)
;
if
(
flags
&
HASH_SET_TAKE_VALUE
&
&
value
)
<UNK>
(
value
)
;
return
update
;
}
int
<UNK>
(
robj
*
o
,
sds
field
)
{
int
deleted
=
<int>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
,
*
fptr
;
zl
=
o
-
>
ptr
;
fptr
=
ziplistIndex
(
zl
,
<UNK>
)
;
if
(
fptr
!
=
NULL
)
{
fptr
=
<UNK>
(
fptr
,
(
unsigned
char
*
)
field
,
sdslen
(
field
)
,
<int>
)
;
if
(
fptr
!
=
NULL
)
{
zl
=
<UNK>
(
zl
,
&
fptr
)
;
zl
=
<UNK>
(
zl
,
&
fptr
)
;
o
-
>
ptr
=
zl
;
deleted
=
<int>
;
}
}
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
<UNK>
(
(
dict
*
)
o
-
>
ptr
,
field
)
=
=
C_OK
)
{
deleted
=
<int>
;
if
(
<UNK>
(
o
-
>
ptr
)
)
<UNK>
(
o
-
>
ptr
)
;
}
}
else
{
serverPanic
(
<str>
)
;
}
return
deleted
;
}
unsigned
long
hashTypeLength
(
robj
*
o
)
{
unsigned
long
length
=
<UNK>
;
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
length
=
<UNK>
(
o
-
>
ptr
)
/
<int>
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
length
=
dictSize
(
(
dict
*
)
o
-
>
ptr
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
length
;
}
hashTypeIterator
*
<UNK>
(
robj
*
subject
)
{
hashTypeIterator
*
hi
=
<UNK>
(
sizeof
(
hashTypeIterator
)
)
;
hi
-
>
subject
=
subject
;
hi
-
>
encoding
=
subject
-
>
encoding
;
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
hi
-
>
fptr
=
NULL
;
hi
-
>
vptr
=
NULL
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
hi
-
>
<UNK>
=
<UNK>
(
subject
-
>
ptr
)
;
}
else
{
serverPanic
(
<str>
)
;
}
return
hi
;
}
void
<UNK>
(
hashTypeIterator
*
hi
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
<UNK>
(
hi
-
>
<UNK>
)
;
<UNK>
(
hi
)
;
}
int
<UNK>
(
hashTypeIterator
*
hi
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
zl
;
unsigned
char
*
fptr
,
*
vptr
;
zl
=
hi
-
>
subject
-
>
ptr
;
fptr
=
hi
-
>
fptr
;
vptr
=
hi
-
>
vptr
;
if
(
fptr
=
=
NULL
)
{
serverAssert
(
vptr
=
=
NULL
)
;
fptr
=
ziplistIndex
(
zl
,
<int>
)
;
}
else
{
serverAssert
(
vptr
!
=
NULL
)
;
fptr
=
ziplistNext
(
zl
,
vptr
)
;
}
if
(
fptr
=
=
NULL
)
return
C_ERR
;
vptr
=
ziplistNext
(
zl
,
fptr
)
;
serverAssert
(
vptr
!
=
NULL
)
;
hi
-
>
fptr
=
fptr
;
hi
-
>
vptr
=
vptr
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
if
(
(
hi
-
>
de
=
<UNK>
(
hi
-
>
<UNK>
)
)
=
=
NULL
)
return
C_ERR
;
}
else
{
serverPanic
(
<str>
)
;
}
return
C_OK
;
}
void
<UNK>
(
hashTypeIterator
*
hi
,
int
what
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
int
ret
;
serverAssert
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
if
(
what
&
OBJ_HASH_KEY
)
{
ret
=
<UNK>
(
hi
-
>
fptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
}
else
{
ret
=
<UNK>
(
hi
-
>
vptr
,
vstr
,
vlen
,
vll
)
;
serverAssert
(
ret
)
;
}
}
sds
<UNK>
(
hashTypeIterator
*
hi
,
int
what
)
{
serverAssert
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
;
if
(
what
&
OBJ_HASH_KEY
)
{
return
<UNK>
(
hi
-
>
de
)
;
}
else
{
return
dictGetVal
(
hi
-
>
de
)
;
}
}
void
<UNK>
(
hashTypeIterator
*
hi
,
int
what
,
unsigned
char
*
*
vstr
,
unsigned
int
*
vlen
,
long
long
*
vll
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
*
vstr
=
NULL
;
<UNK>
(
hi
,
what
,
vstr
,
vlen
,
vll
)
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
<UNK>
=
<UNK>
(
hi
,
what
)
;
*
vstr
=
(
unsigned
char
*
)
<UNK>
;
*
vlen
=
sdslen
(
<UNK>
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
sds
<UNK>
(
hashTypeIterator
*
hi
,
int
what
)
{
unsigned
char
*
vstr
;
unsigned
int
vlen
;
long
long
vll
;
<UNK>
(
hi
,
what
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
vstr
)
return
<UNK>
(
vstr
,
vlen
)
;
return
<UNK>
(
vll
)
;
}
robj
*
hashTypeLookupWriteOrCreate
(
client
*
c
,
robj
*
key
)
{
robj
*
o
=
<UNK>
(
c
-
>
db
,
key
)
;
if
(
o
=
=
NULL
)
{
o
=
<UNK>
(
)
;
<UNK>
(
c
-
>
db
,
key
,
o
)
;
}
else
{
if
(
o
-
>
type
!
=
OBJ_HASH
)
{
addReply
(
c
,
shared
.
<UNK>
)
;
return
NULL
;
}
}
return
o
;
}
void
<UNK>
(
robj
*
o
,
int
enc
)
{
serverAssert
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
;
if
(
enc
=
=
OBJ_ENCODING_ZIPLIST
)
{
}
else
if
(
enc
=
=
OBJ_ENCODING_HT
)
{
hashTypeIterator
*
hi
;
dict
*
dict
;
int
ret
;
hi
=
<UNK>
(
o
)
;
dict
=
<UNK>
(
&
<UNK>
,
NULL
)
;
while
(
<UNK>
(
hi
)
!
=
C_ERR
)
{
sds
key
,
value
;
key
=
<UNK>
(
hi
,
OBJ_HASH_KEY
)
;
value
=
<UNK>
(
hi
,
OBJ_HASH_VALUE
)
;
ret
=
<UNK>
(
dict
,
key
,
value
)
;
if
(
ret
!
=
<UNK>
)
{
<UNK>
(
LL_WARNING
,
<str>
,
o
-
>
ptr
,
<UNK>
(
o
-
>
ptr
)
)
;
serverPanic
(
<str>
)
;
}
}
<UNK>
(
hi
)
;
<UNK>
(
o
-
>
ptr
)
;
o
-
>
encoding
=
OBJ_ENCODING_HT
;
o
-
>
ptr
=
dict
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
<UNK>
(
robj
*
o
,
int
enc
)
{
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
<UNK>
(
o
,
enc
)
;
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
serverPanic
(
<str>
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
<UNK>
(
client
*
c
)
{
int
update
;
robj
*
o
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
<int>
)
;
update
=
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
<UNK>
)
;
addReply
(
c
,
update
?
shared
.
czero
:
shared
.
cone
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
<int>
)
;
if
(
<UNK>
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
)
{
addReply
(
c
,
shared
.
czero
)
;
}
else
{
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
<UNK>
)
;
addReply
(
c
,
shared
.
cone
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
}
void
<UNK>
(
client
*
c
)
{
int
i
;
robj
*
o
;
if
(
(
c
-
>
argc
%
<int>
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
hashTypeTryConversion
(
o
,
c
-
>
argv
,
<int>
,
c
-
>
argc
-
<int>
)
;
for
(
i
=
<int>
;
i
<
c
-
>
argc
;
i
+
=
<int>
)
{
hashTypeSet
(
o
,
c
-
>
argv
[
i
]
-
>
ptr
,
c
-
>
argv
[
i
+
<int>
]
-
>
ptr
,
<UNK>
)
;
}
addReply
(
c
,
shared
.
<UNK>
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
<UNK>
(
client
*
c
)
{
long
long
value
,
incr
,
oldvalue
;
robj
*
o
;
sds
new
;
unsigned
char
*
vstr
;
unsigned
int
vlen
;
if
(
<UNK>
(
c
,
c
-
>
argv
[
<int>
]
,
&
incr
,
NULL
)
!
=
C_OK
)
return
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
if
(
hashTypeGetValue
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
&
vstr
,
&
vlen
,
&
value
)
=
=
C_OK
)
{
if
(
vstr
)
{
if
(
<UNK>
(
(
char
*
)
vstr
,
vlen
,
&
value
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
}
}
else
{
value
=
<int>
;
}
oldvalue
=
value
;
if
(
(
incr
<
<int>
&
&
oldvalue
<
<int>
&
&
incr
<
(
<UNK>
-
oldvalue
)
)
|
|
(
incr
>
<int>
&
&
oldvalue
>
<int>
&
&
incr
>
(
LLONG_MAX
-
oldvalue
)
)
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
value
+
=
incr
;
new
=
<UNK>
(
value
)
;
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
new
,
HASH_SET_TAKE_VALUE
)
;
addReplyLongLong
(
c
,
value
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
}
void
<UNK>
(
client
*
c
)
{
long
<UNK>
value
,
incr
;
long
long
<UNK>
;
robj
*
o
;
sds
new
;
unsigned
char
*
vstr
;
unsigned
int
vlen
;
if
(
<UNK>
(
c
,
c
-
>
argv
[
<int>
]
,
&
incr
,
NULL
)
!
=
C_OK
)
return
;
if
(
(
o
=
hashTypeLookupWriteOrCreate
(
c
,
c
-
>
argv
[
<int>
]
)
)
=
=
NULL
)
return
;
if
(
hashTypeGetValue
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
&
vstr
,
&
vlen
,
&
<UNK>
)
=
=
C_OK
)
{
if
(
vstr
)
{
if
(
<UNK>
(
(
char
*
)
vstr
,
vlen
,
&
value
)
=
=
<int>
)
{
addReplyError
(
c
,
<str>
)
;
return
;
}
}
else
{
value
=
(
long
<UNK>
)
<UNK>
;
}
}
else
{
value
=
<int>
;
}
value
+
=
incr
;
char
buf
[
<int>
]
;
int
len
=
<UNK>
(
buf
,
sizeof
(
buf
)
,
value
,
<int>
)
;
new
=
<UNK>
(
buf
,
len
)
;
hashTypeSet
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
,
new
,
HASH_SET_TAKE_VALUE
)
;
addReplyBulkCBuffer
(
c
,
buf
,
len
)
;
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
+
;
robj
*
aux
,
*
newobj
;
aux
=
createStringObject
(
<str>
,
<int>
)
;
newobj
=
<UNK>
(
buf
,
len
)
;
<UNK>
(
c
,
<int>
,
aux
)
;
decrRefCount
(
aux
)
;
<UNK>
(
c
,
<int>
,
newobj
)
;
decrRefCount
(
newobj
)
;
}
static
void
<UNK>
(
client
*
c
,
robj
*
o
,
sds
field
)
{
int
ret
;
if
(
o
=
=
NULL
)
{
addReply
(
c
,
shared
.
nullbulk
)
;
return
;
}
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
ret
=
hashTypeGetFromZiplist
(
o
,
field
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
ret
<
<int>
)
{
addReply
(
c
,
shared
.
nullbulk
)
;
}
else
{
if
(
vstr
)
{
addReplyBulkCBuffer
(
c
,
vstr
,
vlen
)
;
}
else
{
<UNK>
(
c
,
vll
)
;
}
}
}
else
if
(
o
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
=
hashTypeGetFromHashTable
(
o
,
field
)
;
if
(
value
=
=
NULL
)
addReply
(
c
,
shared
.
nullbulk
)
;
else
addReplyBulkCBuffer
(
c
,
value
,
sdslen
(
value
)
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
nullbulk
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
<UNK>
(
c
,
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
int
i
;
o
=
<UNK>
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
if
(
o
!
=
NULL
&
&
o
-
>
type
!
=
OBJ_HASH
)
{
addReply
(
c
,
shared
.
<UNK>
)
;
return
;
}
<UNK>
(
c
,
c
-
>
argc
-
<int>
)
;
for
(
i
=
<int>
;
i
<
c
-
>
argc
;
i
+
+
)
{
<UNK>
(
c
,
o
,
c
-
>
argv
[
i
]
-
>
ptr
)
;
}
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
int
j
,
deleted
=
<int>
,
<UNK>
=
<int>
;
if
(
(
o
=
<UNK>
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
for
(
j
=
<int>
;
j
<
c
-
>
argc
;
j
+
+
)
{
if
(
<UNK>
(
o
,
c
-
>
argv
[
j
]
-
>
ptr
)
)
{
deleted
+
+
;
if
(
hashTypeLength
(
o
)
=
=
<int>
)
{
<UNK>
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
<UNK>
=
<int>
;
break
;
}
}
}
if
(
deleted
)
{
signalModifiedKey
(
c
-
>
db
,
c
-
>
argv
[
<int>
]
)
;
notifyKeyspaceEvent
(
NOTIFY_HASH
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
if
(
<UNK>
)
notifyKeyspaceEvent
(
<UNK>
,
<str>
,
c
-
>
argv
[
<int>
]
,
c
-
>
db
-
>
id
)
;
server
.
dirty
+
=
deleted
;
}
addReplyLongLong
(
c
,
deleted
)
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReplyLongLong
(
c
,
hashTypeLength
(
o
)
)
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReplyLongLong
(
c
,
<UNK>
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
)
;
}
static
void
<UNK>
(
client
*
c
,
hashTypeIterator
*
hi
,
int
what
)
{
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_ZIPLIST
)
{
unsigned
char
*
vstr
=
NULL
;
unsigned
int
vlen
=
UINT_MAX
;
long
long
vll
=
LLONG_MAX
;
<UNK>
(
hi
,
what
,
&
vstr
,
&
vlen
,
&
vll
)
;
if
(
vstr
)
addReplyBulkCBuffer
(
c
,
vstr
,
vlen
)
;
else
<UNK>
(
c
,
vll
)
;
}
else
if
(
hi
-
>
encoding
=
=
OBJ_ENCODING_HT
)
{
sds
value
=
<UNK>
(
hi
,
what
)
;
addReplyBulkCBuffer
(
c
,
value
,
sdslen
(
value
)
)
;
}
else
{
serverPanic
(
<str>
)
;
}
}
void
genericHgetallCommand
(
client
*
c
,
int
flags
)
{
robj
*
o
;
hashTypeIterator
*
hi
;
int
multiplier
=
<int>
;
int
length
,
count
=
<int>
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
<UNK>
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
if
(
flags
&
OBJ_HASH_KEY
)
multiplier
+
+
;
if
(
flags
&
OBJ_HASH_VALUE
)
multiplier
+
+
;
length
=
hashTypeLength
(
o
)
*
multiplier
;
<UNK>
(
c
,
length
)
;
hi
=
<UNK>
(
o
)
;
while
(
<UNK>
(
hi
)
!
=
C_ERR
)
{
if
(
flags
&
OBJ_HASH_KEY
)
{
<UNK>
(
c
,
hi
,
OBJ_HASH_KEY
)
;
count
+
+
;
}
if
(
flags
&
OBJ_HASH_VALUE
)
{
<UNK>
(
c
,
hi
,
OBJ_HASH_VALUE
)
;
count
+
+
;
}
}
<UNK>
(
hi
)
;
serverAssert
(
count
=
=
length
)
;
}
void
<UNK>
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_KEY
)
;
}
void
<UNK>
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_VALUE
)
;
}
void
<UNK>
(
client
*
c
)
{
genericHgetallCommand
(
c
,
OBJ_HASH_KEY
|
OBJ_HASH_VALUE
)
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
czero
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
addReply
(
c
,
<UNK>
(
o
,
c
-
>
argv
[
<int>
]
-
>
ptr
)
?
shared
.
cone
:
shared
.
czero
)
;
}
void
<UNK>
(
client
*
c
)
{
robj
*
o
;
unsigned
long
<UNK>
;
if
(
<UNK>
(
c
,
c
-
>
argv
[
<int>
]
,
&
<UNK>
)
=
=
C_ERR
)
return
;
if
(
(
o
=
lookupKeyReadOrReply
(
c
,
c
-
>
argv
[
<int>
]
,
shared
.
<UNK>
)
)
=
=
NULL
|
|
checkType
(
c
,
o
,
OBJ_HASH
)
)
return
;
<UNK>
(
c
,
o
,
<UNK>
)
;
}
<EOF>
